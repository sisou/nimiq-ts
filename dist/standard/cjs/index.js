'use strict';

function _loadWasmModule (sync, filepath, src, imports) {
  function _instantiateOrCompile(source, imports, stream) {
    var instantiateFunc = stream ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
    var compileFunc = stream ? WebAssembly.compileStreaming : WebAssembly.compile;

    if (imports) {
      return instantiateFunc(source, imports)
    } else {
      return compileFunc(source)
    }
  }

  
var buf = null;
var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
if (isNode) {
  
buf = Buffer.from(src, 'base64');

} else {
  
var raw = globalThis.atob(src);
var rawLength = raw.length;
buf = new Uint8Array(new ArrayBuffer(rawLength));
for(var i = 0; i < rawLength; i++) {
   buf[i] = raw.charCodeAt(i);
}

}


  if(sync) {
    var mod = new WebAssembly.Module(buf);
    return imports ? new WebAssembly.Instance(mod, imports) : mod
  } else {
    return _instantiateOrCompile(buf, imports, false)
  }
}

function nimiqWasm(imports){return _loadWasmModule(0, null, 'AGFzbQEAAAAB0IGAgAAaYAN/f38Bf2ACf38AYAJ/fwF/YAF8AX9gAX8AYAABf2AAAGABfwF/YAN/f38AYAR/f39/AX9gCH9/f39/f39/AX9gB39/f39/f38Bf2AOf39/f39/f39/f39/f38Bf2AJf39/f39/f39/AX9gCn9/f39/f39/f38Bf2ACfn4BfmAGf39/f39/AX9gBH9/f38AYAl/f39/f39/f38AYAV/f39/fwBgBX9/f39/AX9gA35/fwF/YAJ+fwF/YAZ/fH9/f38Bf2ABfAF+YAJ8fwF8AqCCgIAADwNlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52BWFib3J0AAQDZW52DWVubGFyZ2VNZW1vcnkABQNlbnYOZ2V0VG90YWxNZW1vcnkABQNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkABQNlbnYGX2Fib3J0AAYDZW52Fl9lbXNjcmlwdGVuX21lbWNweV9iaWcAAANlbnYLX19fc2V0RXJyTm8ABAhhc20yd2FzbQpmNjQtdG8taW50AAMDZW52Bm1lbW9yeQIBgAKAAgNlbnYFdGFibGUBcAEGBgNlbnYKbWVtb3J5QmFzZQN/AANlbnYJdGFibGVCYXNlA38AA6GBgIAAnwEHBQQBAQQFAQAICAkJCgoLCQICAgwNDgEBAQEBAQ8JBwcBCAICCQIJAAEAEAkBBAgBCBERCAgIAAQECAgBAQEBCAcBBwEBAQgIAhEBCAgIAQECBAEBCAEBAQUFBAcRBwABAgASEwkBEQUFBQUHAgAABwQHBwAACQAUCAcIFRYPFgcTAgIXGBkZAAICAgACAAcABwQABgcHBwAJCAAAAQIGn4CAgAAGfwEjAAt/ASMBC38BIwILfwFBAAt/AUEAC38BQQALB7uGgIAAKA1fZWQyNTUxOV9zaWduAGwRX25pbWlxX2tkZl9sZWdhY3kAFRRfbmltaXFfYXJnb24yX3ZlcmlmeQAYDV9uaW1pcV9ibGFrZTIAEAdfbWFsbG9jAJkBIl9lZDI1NTE5X2RlbGluZWFyaXplZF9wYXJ0aWFsX3NpZ24Aaw1fbmltaXFfc2hhNTEyABIFX3NicmsAnQEoX2VkMjU1MTlfZGVyaXZlX2RlbGluZWFyaXplZF9wcml2YXRlX2tleQA6Cl9uaW1pcV9rZGYAFhRfbmltaXFfYXJnb24yX3RhcmdldAAXDV9uaW1pcV9hcmdvbjIAEx9fZWQyNTUxOV9kZWxpbmVhcml6ZV9wdWJsaWNfa2V5ADwUX2VkMjU1MTlfYWRkX3NjYWxhcnMAPhpfZWQyNTUxOV9wdWJsaWNfa2V5X2Rlcml2ZQBgGl9lZDI1NTE5X2NyZWF0ZV9jb21taXRtZW50AD8PX2xsdm1fYnN3YXBfaTE2AJ8BG19lbXNjcmlwdGVuX2dldF9nbG9iYWxfbGliYwBwD19lZDI1NTE5X3ZlcmlmeQBtF19nZXRfc3RhdGljX21lbW9yeV9zaXplAGIPX2xsdm1fYnN3YXBfaTMyAJ4BBV9mcmVlAJoBGF9nZXRfc3RhdGljX21lbW9yeV9zdGFydABhDV9uaW1pcV9zaGEyNTYAERlfZWQyNTUxOV9oYXNoX3B1YmxpY19rZXlzADkVX25pbWlxX2FyZ29uMl9ub193aXBlABQHX21lbWNweQCgAR5fZWQyNTUxOV9hZ2dyZWdhdGVfY29tbWl0bWVudHMAPStfZWQyNTUxOV9hZ2dyZWdhdGVfZGVsaW5lYXJpemVkX3B1YmxpY19rZXlzADsLcnVuUG9zdFNldHMAnAEKc3RhY2tBbGxvYwAICXN0YWNrU2F2ZQAJDHN0YWNrUmVzdG9yZQAKE2VzdGFibGlzaFN0YWNrU3BhY2UACwtzZXRUZW1wUmV0MAANC2dldFRlbXBSZXQwAA4Ic2V0VGhyZXcADAxkeW5DYWxsX2lpaWkAoQELZHluQ2FsbF92aWkAogELZHluQ2FsbF9paWkAowEJkoCAgAABACMECwakAZsBmAGkAaUBpgEKzJGEgACfAZ6AgIAAAQF/An8jBiEBIwYgAGokBiMGQQ9qQXBxJAYgAQsLhICAgAAAIwYLhoCAgAAAIAAkBguNgICAAAACQCAAJAYgASQHCwuQgICAAAAjCEUEQCAAJAggASQJCwuGgICAAAAgACQKC4SAgIAAACMKC4mEgIAAAgR/AX4CQCABKQMAIQZBgAgsAAAhAiACQSpGBEAgBqdB//8DcRCfAUH//wNxIQUgBqdBEHYQnwFB//8DcSEDIAZCIIinQf//A3EQnwFB//8DcSEEIAZCMIinQf//A3EQ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IQFBbiABDQQaCyAAKAIQIQIgACgCFCEBIAIgAUVyBH8gAUEISQR/QXoFIAAoAhghASABRQRAIAAoAhxFIQFBbCABRQ0GGgsgACgCICEBIAFFBEAgACgCJEUhAUFrIAFFDQYaCyAAKAIsIQEgAUEISQR/QXIFIAFBgICAAUsEf0FxBSAAKAIwIQIgASACQQN0SQR/QXIFIAAoAighASABBH8gAgR/IAJB////B0sEf0FvBSAAKAI0IQEgAQR/IAFB////B0sEf0FjBSAAKAI8IQEgACgCQEUhACABBH9BaSAADQ4FQWggAEUNDgsaQQALBUFkCwsFQXALBUF0CwsLCwsFQW0LCwVBfwsFQWcLCyIAC8WCgIAAAgp/AX4CQCMGIQUjBkGACGokBiAFIQQgAUEYaiIKKAIAIQMgAwRAIABBwABqIQggAEHEAGohCyABQRRqIQlBACEDA0AgCEEANgAAIAsgAzYAACAEQYAIIABByAAQNBogASgCACEGIAkoAgAhAiACIANsIQdBACECA0AgBCACQQN0aikAACEMIAYgB0EKdGogAkEDdGogDDcDACACQQFqIgJBgAFHDQALIAhBATYAACAEQYAIIABByAAQNBogASgCACEGIAkoAgAhAiACIANsQQFqIQdBACECA0AgBCACQQN0aikAACEMIAYgB0EKdGogAkEDdGogDDcDACACQQFqIgJBgAFHDQALIAooAgAhAiADQQFqIgMgAkkNAAsLIAEoAighACAAKAJEIQAgAEEEcQRAIAUkBg8LIARBgAgQIiAFJAYLC4GEgIAAAQZ/AkAjBiEHIwZBgAJqJAYgAEUgAUVyBEAgByQGDwsgByIFQcAAEC4aIAEoAjAhAyAHQfABaiIEIAM2AgAgBSAEQQQQMBogASgCBCEDIAQgAzYCACAFIARBBBAwGiABKAIsIQMgBCADNgIAIAUgBEEEEDAaIAEoAighAyAEIAM2AgAgBSAEQQQQMBogASgCOCEDIAQgAzYCACAFIARBBBAwGiAEIAI2AgAgBSAEQQQQMBogAUEMaiICKAIAIQMgBCADNgIAIAUgBEEEEDAaIAFBCGoiBigCACEDIAMEQCACKAIAIQggBSADIAgQMBogASgCRCEDIANBAXEEQCAGKAIAIQMgAigCACEGIAMgBhAiIAJBADYCAAsLIAFBFGoiAygC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gAEQMBogBUGAARAjIAQkBkEADwsgAEHwARAjIAAsAOgBIQEgAQRAIABCfzcDWAsgAEJ/NwNQIAQkBkF/CwvggoCAAAIHfwJ+An8gAkUEQEEADwsgAEUgAUVyBEBBfw8LIAApA1AhCiAKQgBSBEBBfw8LIABB4AFqIgUoAgAhAyADIAJqIglBgAFLBH8gAEHgAGogA2ogAUGAASADayIGEKABGiAAQcAAaiIHKQMAIQsgByALQoABfDcDACAAQcgAaiIIKQMAIQogCCALQv9+Vq0gCnw3AwAgACAAQeAAahAxIAVBADYCACABIAZqIQQgAiAGayICQYABSwR/IAlB/31qQYB/cSIGQYACaiADayEDA0AgBykDACELIAcgC0KAAXw3AwAgCCkDACEKIAggC0L/flatIAp8NwMAIAAgBBAxIARBgAFqIQQgAkGAf2oiAkGAAUsNAAsgCUGAfmogBmshAiABIANqIQEgBSgCAAUgBCEBQQALBSADCyEEIABB4ABqIARqIAEgAhCgARogBSgCACEAIAUgACACajYCAEEACwuvj4CAAAIDfxN+AkAjBiEEIwZBgAJqJAYgBEGAAWoiAiABKQAANwAAIAIgASkACDcACCACIAEpABA3ABAgAiABKQAYNwAYIAIgASkAIDcAICACIAEpACg3ACggAiABKQAwNwAwIAIgASkAODcAOCACIAEpAEA3AEAgAiABKQBINwBIIAIgASkAUDcAUCACIAEpAFg3AFggAiABKQBgNwBgIAIgASkAaDcAaCACIAEpAHA3AHAgAiABKQB4NwB4IAQiASAAKQMANwMAIAEgACkDCDcDCCABIAApAxA3AxAgASAAKQMYNwMYIAEgACkDIDcDICABIAApAyg3AyggASAAKQMwNwMwIAEgACkDODcDOCABQoiS853/zPmE6gA3A0AgAUK7zqqm2NDrs7t/NwNIIAFCq/DT9K/uvLc8NwNQIAFC8e30+KWn/aelfzcDWCAAKQNAIQUgASAFQtGFmu/6z5SH0QCFIhA3A2AgACkDSCEFIAEgBUKf2PnZwpHagpt/hSIPNwNoIAApA1AhBSABIAVC6/qG2r+19sEfhSIMNwNwIAApA1ghBSABIAVC+cL4m5Gjs/DbAIUiDjcDeCABKQMAIQggASkDICEHIAEpAwghDSABKQMoIQUgASkDECEJ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gICAAAEBfwJAIABBATYCACAAQQRqIgFCADcCACABQgA3AgggAUIANwIQIAFCADcCGCABQQA2AiALC/eBgIAAARJ/AkAgASgCACEDIAEoAgQhBCABKAIIIQUgASgCDCEGIAEoAhAhByABKAIUIQggASgCGCEJIAEoAhwhCiABKAIgIQsgASgCJCEBIAIoAgAhDCACKAIEIQ0gAigCCCEOIAIoAgwhDyACKAIQIRAgAigCFCERIAIoAhghEiACKAIcIRMgAigCICEUIAIoAiQhAiAAIAwgA2o2AgAgACANIARqNgIEIAAgDiAFajYCCCAAIA8gBmo2AgwgACAQIAdqNgIQIAAgESAIajYCFCAAIBIgCWo2AhggACATIApqNgIcIAAgFCALajYCICAAIAIgAWo2AiQLC+WCgIAAARx/AkAgACgCACEDIABBBGoiDSgCACEEIABBCGoiDigCACEFIABBDGoiDygCACEGIABBEGoiECgCACEHIABBFGoiESgCACEIIABBGGoiEigCACEJIABBHGoiEygCACEKIABBIGoiFCgCACELIABBJGoiFSgCACEMIAEoAgAhFiABKAIEIRcgASgCCCEYIAEoAgwhGSABKAIQIRogASgCFCEbIAEoAhghHCABKAIcIR0gASgCICEeIAEoAiQhASAAIBYgA3NBACACayIAcSADczYCACANIBcgBHMgAHEgBHM2AgAgDiAYIAVzIABxIAVzNgIAIA8gGSAGcyAAcSAGczYCACAQIBogB3MgAHEgB3M2AgAgESAbIAhzIABxIAhzNgIAIBIgHCAJcyAAcSAJczYCACATIB0gCnMgAHEgCnM2AgAgFCAeIAtzIABxIAtzNgIAIBUgASAMcyAAcSAMczYCAAsLk4GAgAABCX8CQCABKAIAIQIgASgCBCEDIAEoAgghBCABKAIMIQUgASgCECEGIAEoAhQhByABKAIYIQggASgCHCEJIAEoAiAhCiABKAIkIQEgACACNgIAIAAgAzYCBCAAIAQ2AgggACAFNgIMIAAgBjYCECAAIAc2AhQgACAINgIYIAAgCTYCHCAAIAo2AiAgACABNgIkCwvdhYCAAAIYfxR+AkAgAS0AACECIAEtAAEhAyABLQACIQQgAS0AAyEFIAEtAAUhBiABLQAGIQcgAS0ABK0hGiABLQAIIQggAS0ACSEJ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ByAALAACIQggASwAAyEJIAAsAAMhCiABLAAEIQsgACwABCEMIAEsAAUhDSAALAAFIQ4gASwABiEPIAAsAAYhECABLAAHIREgACwAByESIAEsAAghEyAALAAIIRQgASwACSEVIAAsAAkhFiABLAAKIRcgACwACiEYIAEsAAshGSAALAALIRogASwADCEbIAAsAAwhHCABLAANIR0gACwADSEeIAEsAA4hHyAALAAOISAgASwADyEhIAAsAA8hIiABLAAQISMgACwAECEkIAEsABEhJSAALAARISYgASwAEiEnIAAsABIhKCABLAATISkgACwAEyEqIAEsABQhKyAALAAUISwgASwAFSEtIAAsABUhLiABLAAWIS8gACwAFiEwIAEsABchMSAALAAXITIgASwAGCEzIAAsABghNCABLAAZITUgACwAGSE2IAEsABohNyAALAAaITggASwAGyE5IAAsABshOiABLAAcITsgACwAHCE8IAEsAB0hPSAALAAdIT4gASwAHiE/IAAsAB4hQCABLAAfIQEgACwAHyEAIAUkBiAGIARzIAMgAnNyIAggB3NyIAogCXNyIAwgC3NyIA4gDXNyIBAgD3NyIBIgEXNyIBQgE3NyIBYgFXNyIBggF3NyIBogGXNyIBwgG3NyIB4gHXNyICAgH3NyICIgIXNyICQgI3NyICYgJXNyICggJ3NyICogKXNyICwgK3NyIC4gLXNyIDAgL3NyIDIgMXNyIDQgM3NyIDYgNXNyIDggN3NyIDogOXNyIDwgO3NyID4gPXNyIEAgP3NyIAAgAXNyQf8BcUULC8uJgIAAAhR/An4CQCMGIQwjBkGAGGokBiAARQRAIAwkBg8LIAxBgBBqIQ0gDEGACGohByAMIQggAEEgaiIEKAIAIQYCQAJAAkACQAJAAkACQCAGQQFrDgIAAQILIAEhBiABQQhqIQMMAgsgASgCACEGIAYEQCABIQZBACEEDAQFIAFBCGoiAy0AACEGIAZB/wFxQQJIBEAgASEGDAMFIAFBCGoiCywAACEGIAYEf0EABUECCyEDIAEhBkEAIQQLCwwECyABIQYgASgCACEDQQAhBAwBCyAIQQAQHyAHQQAQHyAGKAIAIQsgByALrTcDACABKAIEIQIgByACrTcDCCADLQAAIQMgByADQf8Bca03AxAgACgCDCEDIAcgA603AxggACgCCCEDIAcgA603AyAgBCgCACEDIAcgA603AyggCyEDQQEhBAsgAw0AIAFBCGoiCywAACEDIANBAEciAyAEQQFzciECIAMEf0EABUECCyEDIAJFBEAgB0EwaiIDKQMAIRYgAyAWQgF8NwMAIAggByANQQAQbyAIIA0gDUEAEG9BAiEDCwwBC0EAIQMgAUEIaiELCyABQQRqIg4oAgAhCSAAQRRqIg8oAgAhAiALLQAAIQogAEEQaiIRKAIAIQUgAiAJbCADaiAKQf8BcSAFbGoiCSACECwhCiADIAVPBEAgDCQGDwsgAkF/aiEFIAoEf0F/BSAFCyAJaiEFIABBGGohEiABQQxqIRMgAEEEaiEUIARFBEADQCAJIAIQLCECIAlBf2ohBCAAKAIAIQggCCACQQFGBH8gBAUgBSIEC0EKdGopAwAhFyASKAIAIQIgF0IgiCACrRAlIRYgBigCACECIAJFBEAgCywAACECIAJFBEAgDigCACECIAKtIRYLCyATIAM2AgAgDigCACECIAAgASAXpyAWIAKtURAmIQUgACgCACECIA8oAgAhCCACIAitIBZ+p0EKdGogBUEKdGohBSACIAlBCnRqIQggFCgCACEHIAdBEEYEQCACIARBCnRqIAUgCEEAEG8FIAYoAgAhByACIARBCnRqIQIgBwRAIAIgBSAIQQEQbwUgAiAFIAhBABBvCwsgESgCACECIANBAWoiAyACSQRAIAlBAWohCSAEQQFqIQUgDygCACECDAELCyAMJAYPCyAHQTBqIRUDQCAJIAIQLCECIANB/wBxIgRFBEAgFSkDACEWIBUgFkIBfDcDACAIIAcgDUEAEG8gCCANIA1BABBvCyANIARBA3RqKQMAIRcgEigCACEEIBdCIIggBK0QJSEWIAYoAgAhBCAERQRAIAssAAAhBCAERQRAIA4oAgAhBCAErSEWCwsgCUF/aiEEIAJBAUcEQCAFIQQLIBMgAzYCACAOKAIAIQIgACABIBenIBYgAq1RECYhBSAAKAIAIQIgDygCACEKIAIgCq0gFn6nQQp0aiAFQQp0aiEFIAIgCUEKdGohCiAUKAIAIRAgEEEQRgRAIAIgBEEKdGogBSAKQQAQbwUgBigCACEQIAIgBEEKdGohAiAQBEAgAiAFIApBARBvBSACIAUgCkEAEG8LCyARKAIAIQIgA0EBaiIDIAJJBEAgCUEBaiEJIARBAWohBSAPKAIAIQIMAQsLIAwkBgsLu6CAgAACEX8GfgJAIwYhEiMGQYAQaiQGIBJBgAhqIgQgARAgIAQgABAhIBIiASAEECAgAwR/IAEgAhAhQQAFQQALIQADQCAEIABBBHQiA0EDdGoiBSkDACEWIAQgA0EEckEDdGoiBikDACEVIAQgA0EMckEDdGoiBykDACEYIBUgFnwgFkIBhkL+////H4MgFUL/////D4N+fCIWIBiFIhlCIIghGCAEIANBCHJBA3RqIggpAwAhFyAZQiCGIBiEIhkgF3wgF0IBhkL+////H4MgGH58IhggFYUiF0IYiCEVIAUgF0IohiAVhCIXIBZ8IBVC/////w+DIBZCAYZC/v///x+DfnwiFTcDACAVIBmFIhZCEIghFSAHIBZCMIYgFYQiFjcDACAIIBYgGHwgFUL/////D4MgGEIBhkL+////H4N+fCIVNwMAIAYgFSAXhSIVQgGGIBVCP4iENwMAIAQgA0EBckEDdGoiCSkDACEWIAQgA0EFckEDdGoiCikDACEVIAQgA0ENckEDdGoiCykDACEYIBUgFnwgFkIBhkL+////H4MgFUL/////D4N+fCIWIBiFIhlCIIghGCAEIANBCXJBA3RqIgwpAwAhFyAZQiCGIBiEIhkgF3wgF0IBhkL+////H4MgGH58IhggFYUiF0IYiCEVIAkgF0IohiAVhCIXIBZ8IBVC/////w+DIBZCAYZC/v///x+DfnwiFTcDACAVIBmFIhZCEIghFSALIBZCMIYgFYQiFjcDACAMIBYgGHwgFUL/////D4MgGEIBhkL+////H4N+fCIVNwMAIAogFSAXhSIVQgGGIBVCP4iENwMAIAQgA0ECckEDdGoiDSkDACEWIAQgA0EGckEDdGoiDikDACEVIAQgA0EOckEDdGoiDykDACEYIBUgFnwgFkIBhkL+////H4MgFUL/////D4N+fCIWIBiFIhlCIIghGCAEIANBCnJBA3RqIhMpAwAhFyAZQiCGIBiEIhkgF3wgF0IBhkL+////H4MgGH58IhggFYUiF0IYiCEVIA0gF0IohiAVhCIXIBZ8IBVC/////w+DIBZCAYZC/v///x+DfnwiFTcDACAVIBmFIhZCEIghFSAPIBZCMIYgFYQiFjcD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////D4MgFkIBhkL+////H4N+fCIVNwMAIBUgGYUiFkIQiCEVIAcgFkIwhiAVhCIWNwMAIAMgFiAYfCAVQv////8PgyAYQgGGQv7///8fg358IhU3AwAgDiAVIBeFIhVCAYYgFUI/iIQ3AwAgDSkDACEWIBEpAwAhFSALKQMAIRggFSAWfCAWQgGGQv7///8fgyAVQv////8Pg358IhYgGIUiGUIgiCEYIAgpAwAhFyAZQiCGIBiEIhkgF3wgF0IBhkL+////H4MgGH58IhggFYUiF0IYiCEVIA0gF0IohiAVhCIXIBZ8IBVC/////w+DIBZCAYZC/v///x+DfnwiFTcDACAVIBmFIhZCEIghFSALIBZCMIYgFYQiFjcDACAIIBYgGHwgFUL/////D4MgGEIBhkL+////H4N+fCIVNwMAIBEgFSAXhSIVQgGGIBVCP4iENwMAIBApAwAhFiAGKQMAIRUgDykDACEYIBUgFnwgFkIBhkL+////H4MgFUL/////D4N+fCIWIBiFIhlCIIghGCAMKQMAIRcgGUIghiAYhCIZIBd8IBdCAYZC/v///x+DIBh+fCIYIBWFIhdCGIghFSAQIBdCKIYgFYQiFyAWfCAVQv////8PgyAWQgGGQv7///8fg358IhU3AwAgFSAZhSIWQhCIIRUgDyAWQjCGIBWEIhY3AwAgDCAWIBh8IBVC/////w+DIBhCAYZC/v///x+DfnwiFTcDACAGIBUgF4UiFUIBhiAVQj+IhDcDACAAQQFqIgBBCEcNAAsgAiABECAgAiAEECEgEiQGCwuGgICAAABBkKQCC4iAgIAAABByQcAAaguEgICAAAAQcwuGgICAAABBxI0CC5CBgIAAAQN/An8CQAJAIAAiAkEDcUUNACAAIQEgAiEAA0AgASwAAEUNAiABQQFqIgEiAEEDcQ0AIAEhAAwBCwAMAQsDQCAAQQRqIQEgACgCACIDQYCBgoR4cUGAgYKEeHMgA0H//ft3anFFBEAgASEADAELCyADQf8BcQRAA0AgAEEBaiIALAAADQALCwsgACACawsL4YCAgAABAn8CfyAALAAAIgJFIAIgASwAACIDR3IEQCADIQAgAiEBBQNAIABBAWoiACwAACICRSACIAFBAWoiASwAACIDR3IEQCADIQAgAiEBBQwBCwsLIAFB/wFxIABB/wFx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gICAAAAgACABEI8BC4qRgIAAAQJ+AnwCQAJAAkACQCAAvSICQjSIIgOnQf8PcQ6AEAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsgASAARAAAAAAAAAAAYgR/IABEAAAAAAAA8EOiIAEQjwEhACABKAIAQUBqBUEACzYCAAwCCwwBCyABIAOnQf8PcUGCeGo2AgAgAkL/////////h4B/g0KAgICAgICA8D+EvyEACyAACwuggoCAAAACfyAABH8gAUGAAUkEQCAAIAE6AABBAQwCCxByKAK8ASgCAEUEQCABQYB/cUGAvwNGBEAgACABOgAAQQEMAwUQcUHUADYCAEF/DAMLAAsgAUGAEEkEQCAAIAFBBnZBwAFyOgAAIAAgAUE/cUGAAXI6AAFBAgwCCyABQYCwA0kgAUGAQHFBgMADRnIEQCAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAEgACABQT9xQYABcjoAAkEDDAILIAFBgIB8akGAgMAASQR/IAAgAUESdkHwAXI6AAAgACABQQx2QT9xQYABcjoAASAAIAFBBnZBP3FBgAFyOgACIAAgAUE/cUGAAXI6AANBBAUQcUHUADYCAEF/CwVBAQsLC4mBgIAAAQJ/An9BACECAkACQAJAA0AgAkGslQJqLQAAIABGDQEgAkEBaiICQdcARw0AQYSWAiEAQdcAIQIMAgsACyACBEBBhJYCIQAMAQVBhJYCIQALDAELA0AgACEDA0AgA0EBaiEAIAMsAAAEQCAAIQMMAQsLIAJBf2oiAg0ACwsgACABKAIUEJIBCwuJgICAAAAgACABEJMBC6WAgIAAAQF/IAEEfyABKAIAIAEoAgQgABCUAQVBAAsiAgR/IAIFIAALC4yDgIAA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AE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAMOTgIAABG5hbWWnAQVhYm9ydAANZW5sYXJnZU1lbW9yeQAOZ2V0VG90YWxNZW1vcnkAF2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAZfYWJvcnQAFl9lbXNjcmlwdGVuX21lbWNweV9iaWcAC19fX3NldEVyck5vAApmNjQtdG8taW50AApzdGFja0FsbG9jAAlzdGFja1NhdmUADHN0YWNrUmVzdG9yZQATZXN0YWJsaXNoU3RhY2tTcGFjZQAIc2V0VGhyZXcAC3NldFRlbXBSZXQwAAtnZXRUZW1wUmV0MAASX3VpbnQyNTZfc2V0X2J5dGVzAA1fbmltaXFfYmxha2UyAA1fbmltaXFfc2hhMjU2AA1fbmltaXFfc2hhNTEyAA1fbmltaXFfYXJnb24yABVfbmltaXFfYXJnb24yX25vX3dpcGUAEV9uaW1pcV9rZGZfbGVnYWN5AApfbmltaXFfa2RmABRfbmltaXFfYXJnb24yX3RhcmdldAAUX25pbWlxX2FyZ29uMl92ZXJpZnkAE19hcmdvbjJfdHlwZTJzdHJpbmcACGkzMnUtZGl2AAtfYXJnb24yX2N0eAANX19hcmdvbjJfaGFzaAARX2FyZ29uMmRfaGFzaF9yYXcAF19hcmdvbjJkX2hhc2hfcmF3X2ZsYWdzABFfaW5pdF9ibG9ja192YWx1ZQALX2NvcHlfYmxvY2sACl94b3JfYmxvY2sAE19zZWN1cmVfd2lwZV9tZW1vcnkAFl9jbGVhcl9pbnRlcm5hbF9tZW1vcnkACV9maW5hbGl6ZQAIaTY0dS1yZW0ADF9pbmRleF9hbHBoYQATX2ZpbGxfbWVtb3J5X2Jsb2NrcwAQX3ZhbGlkYXRlX2lucHV0cwASX2ZpbGxfZmlyc3RfYmxvY2tzAA1faW5pdGlhbF9oYXNoAAtfaW5pdGlhbGl6ZQAIaTMydS1yZW0ADl9lbmNvZGVfc3RyaW5nAA1fYmxha2UyYl9pbml0ABFfYmxha2UyYl9pbml0X2tleQAPX2JsYWtlMmJfdXBkYXRlABFfYmxha2UyYl9jb21wcmVzcwAOX2JsYWtlMmJfZmluYWwACF9ibGFrZTJiAA1fYmxha2UyYl9sb25nABFfc2hhMjU2X3RyYW5zZm9ybQAMX3NoYTI1Nl9pbml0AA5fc2hhMjU2X3VwZGF0ZQANX3NoYTI1Nl9maW5hbAAZX2VkMjU1MTlfaGFzaF9wdWJsaWNfa2V5cwAoX2VkMjU1MTlfZGVyaXZlX2RlbGluZWFyaXplZF9wcml2YXRlX2tleQArX2VkMjU1MTlfYWdncmVnYXRlX2RlbGluZWFyaXplZF9wdWJsaWNfa2V5cwAfX2VkMjU1MTlfZGVsaW5lYXJpemVfcHVibGljX2tleQAeX2VkMjU1MTlfYWdncmVnYXRlX2NvbW1pdG1lbnRzABRfZWQyNTUxOV9hZGRfc2NhbGFycwAaX2VkMjU1MTlfY3JlYXRlX2NvbW1pdG1lbnQABV9mZV8wAAVfZmVfMQAHX2ZlX2FkZAAIX2ZlX2Ntb3YACF9mZV9jb3B5AA1fZmVfZnJvbWJ5dGVzAApfZmVfaW52ZXJ0AAZfZmVfc3EAB19mZV9tdWwADl9mZV9pc25lZ2F0aXZlAAtfZmVfdG9ieXRlcwANX2ZlX2lzbm9uemVybwAHX2ZlX25lZwAMX2ZlX3BvdzIyNTIzAAdfZmVfc3EyAAdfZmVfc3ViAAdfZ2VfYWRkAAhpMzJzLWRpdgAdX2dlX2RvdWJsZV9zY2FsYXJtdWx0X3ZhcnRpbWUACl9nZV9wM19kYmwAB19nZV9zdWIACF9nZV9tYWRkAAhfZ2VfbXN1YgAQX2dlX3AzX3RvX2NhY2hlZAAOX2dlX3AxcDFfdG9fcDMAHF9nZV9mcm9tYnl0ZXNfbmVnYXRlX3ZhcnRpbWUACF9nZV9wM18wAA5fZ2VfcDNfdG9ieXRlcwATX2dlX3NjYWxhcm11bHRfYmFzZQALX3NlbGVjdF8xMTYAC19nZV90b2J5dGVzAB9fZWQyNTUxOV9wcml2YXRlX2tleV9kZWNvbXByZXNzABpfZWQyNTUxOV9wdWJsaWNfa2V5X2Rlcml2ZQAYX2dldF9zdGF0aWNfbWVtb3J5X3N0YXJ0ABdfZ2V0X3N0YXRpY19tZW1vcnlfc2l6ZQAKX3NjX3JlZHVjZQATX3NjX3ZhbGlkX3JlZHVjdGlvbgAKX3NjX211bGFkZAAMX3NoYTUxMl9pbml0AA5fc2hhNTEyX3VwZGF0ZQAQX3NoYTUxMl9jb21wcmVzcwANX3NoYTUxMl9maW5hbAAHX3NoYTUxMgAiX2VkMjU1MTlfZGVsaW5lYXJpemVkX3BhcnRpYWxfc2lnbgANX2VkMjU1MTlfc2lnbgAPX2VkMjU1MTlfdmVyaWZ5AA1fZmlsbF9zZWdtZW50AAtfZmlsbF9ibG9jawAbX2Vtc2NyaXB0ZW5fZ2V0X2dsb2JhbF9saWJjABFfX19lcnJub19sb2NhdGlvbgATX19fcHRocmVhZF9zZWxmXzU2OAANX3B0aHJlYWRfc2VsZgAHX3N0cmxlbgAHX3N0cmNtcAAHX21lbWNtcAAHX21lbWNocgALX19fbG9ja2ZpbGUADV9fX3VubG9ja2ZpbGUABl9odG9ubAALX19fYnN3YXBfMzIACF9zcHJpbnRmAAlfdnNwcmludGYACl92c25wcmludGYACV92ZnByaW50ZgAMX3ByaW50Zl9jb3JlAAhfb3V0XzUzNgALX2dldGludF81MzcADF9wb3BfYXJnXzUzOQAGX2ZtdF94AAZfZm10X28ACGk2NHUtZGl2AAZfZm10X3UACV9zdHJlcnJvcgAEX3BhZAAHX3djdG9tYgAIaTMycy1yZW0AB19mbXRfZnAAEl9fX0RPVUJMRV9CSVRTXzU0MgAHX2ZyZXhwbAAGX2ZyZXhwAAhfd2NydG9tYgANX19fc3RyZXJyb3JfbAAKX19fbGN0cmFucwAPX19fbGN0cmFuc19pbXBsAAxfX19tb19sb29rdXAABl9zd2FwYwAKX19fZndyaXRleAAKX19fdG93cml0ZQAJX3NuX3dyaXRlAAdfbWFsbG9jAAVfZnJlZQAHX21lbXNldAALcnVuUG9zdFNldHMABV9zYnJrAA9fbGx2bV9ic3dhcF9pMzIAD19sbHZtX2Jzd2FwX2kxNgAHX21lbWNweQAMZHluQ2FsbF9paWlpAAtkeW5DYWxsX3ZpaQALZHluQ2FsbF9paWkAAmIwAAJiMQACYjIA', imports)}

let loadModule;
function setWasmInit(init) {
  loadModule = init;
}
class WasmHelper {
  static _module;
  static async doImport() {
    if (WasmHelper._module)
      return;
    if (!loadModule)
      throw new Error("No WebAssembly.Module available");
    const moduleSettings = {};
    const wasmSource = await loadModule();
    if (wasmSource instanceof WebAssembly.Module) {
      moduleSettings.wasmModule = wasmSource;
    } else {
      moduleSettings.wasmBinary = wasmSource;
    }
    const { init } = await Promise.resolve().then(function () { return workerWasm; });
    const runtimeInitialized = new Promise((resolve) => {
      moduleSettings.onRuntimeInitialized = () => resolve(true);
    });
    WasmHelper._module = init(moduleSettings);
    await runtimeInitialized;
  }
  static get Module() {
    if (!WasmHelper._module)
      throw new Error("WebAssembly not loaded, call WasmHelper.doImport() first");
    return WasmHelper._module;
  }
}

class GenesisConfig {
  static CONFIGS = {
    "main": {
      NETWORK_ID: 42,
      NETWORK_NAME: "main"
    },
    "test": {
      NETWORK_ID: 1,
      NETWORK_NAME: "test"
    },
    "dev": {
      NETWORK_ID: 2,
      NETWORK_NAME: "dev"
    }
  };
  static _config;
  static main() {
    GenesisConfig.init(GenesisConfig.CONFIGS["main"]);
  }
  static test() {
    GenesisConfig.init(GenesisConfig.CONFIGS["test"]);
  }
  static dev() {
    GenesisConfig.init(GenesisConfig.CONFIGS["dev"]);
  }
  static init(config) {
    if (GenesisConfig._config)
      throw new Error("GenesisConfig already initialized");
    if (!config.NETWORK_ID)
      throw new Error("Config is missing network id");
    if (!config.NETWORK_NAME)
      throw new Error("Config is missing network name");
    GenesisConfig._config = config;
  }
  static get NETWORK_ID() {
    if (!GenesisConfig._config)
      throw new Error("GenesisConfig not initialized");
    return GenesisConfig._config.NETWORK_ID;
  }
  static get NETWORK_NAME() {
    if (!GenesisConfig._config)
      throw new Error("GenesisConfig not initialized");
    return GenesisConfig._config.NETWORK_NAME;
  }
  static networkIdToNetworkName(networkId) {
    for (const key of Object.keys(GenesisConfig.CONFIGS)) {
      const config = GenesisConfig.CONFIGS[key];
      if (networkId === config.NETWORK_ID) {
        return config.NETWORK_NAME;
      }
    }
    throw new Error(`Unable to find networkName for networkId ${networkId}`);
  }
  static networkIdFromAny(networkId) {
    if (typeof networkId === "number")
      return networkId;
    if (GenesisConfig.CONFIGS[networkId]) {
      return GenesisConfig.CONFIGS[networkId].NETWORK_ID;
    }
    throw new Error(`Unable to find networkId for ${networkId}`);
  }
}

class Policy {
  static BLOCK_TIME = 60;
  static BLOCK_SIZE_MAX = 1e5;
  static BLOCK_TARGET_MAX = BigInt(2) ** BigInt(240);
  static DIFFICULTY_BLOCK_WINDOW = 120;
  static DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;
  static TRANSACTION_VALIDITY_WINDOW = 120;
  static LUNAS_PER_COIN = 1e5;
  static TOTAL_SUPPLY = 21e14;
  static INITIAL_SUPPLY = 252e12;
  static EMISSION_SPEED = Math.pow(2, 22);
  static EMISSION_TAIL_START = 48692960;
  static EMISSION_TAIL_REWARD = 4e3;
  static M = 240;
  static K = 120;
  static DELTA = 0.15;
  static NUM_BLOCKS_VERIFICATION = 250;
  static NUM_SNAPSHOTS_MAX = 20;
  static _supplyCache = /* @__PURE__ */ new Map();
  static _supplyCacheMax = 0;
  static _supplyCacheInterval = 5e3;
  static coinsToLunas(coins) {
    return Math.round(coins * Policy.LUNAS_PER_COIN);
  }
  static lunasToCoins(lunas) {
    return lunas / Policy.LUNAS_PER_COIN;
  }
  static coinsToSatoshis(coins) {
    return Policy.coinsToLunas(coins);
  }
  static satoshisToCoins(satoshis) {
    return Policy.lunasToCoins(satoshis);
  }
  static get SATOSHIS_PER_COIN() {
    return Policy.LUNAS_PER_COIN;
  }
  static supplyAfter(blockHeight) {
    let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;
    startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));
    const startI = startHeight / Policy._supplyCacheInterval;
    const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);
    let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);
    for (let i = startI; i < endI; ++i) {
      startHeight = i * Policy._supplyCacheInterval;
      const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;
      supply = Policy._supplyAfter(supply, endHeight, startHeight);
      Policy._supplyCache.set(endHeight + 1, supply);
      Policy._supplyCacheMax = endHeight + 1;
    }
    return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);
  }
  static _supplyAfter(initialSupply, blockHeight, startHeight = 0) {
    let supply = initialSupply;
    for (let i = startHeight; i <= blockHeight; ++i) {
      supply += Policy._blockRewardAt(supply, i);
    }
    return supply;
  }
  static blockRewardAt(blockHeight) {
    const currentSupply = Policy.supplyAfter(blockHeight - 1);
    return Policy._blockRewardAt(currentSupply, blockHeight);
  }
  static _blockRewardAt(currentSupply, blockHeight) {
    if (blockHeight <= 0)
      return 0;
    const remaining = Policy.TOTAL_SUPPLY - currentSupply;
    if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {
      return Policy.EMISSION_TAIL_REWARD;
    }
    const remainder = remaining % Policy.EMISSION_SPEED;
    return (remaining - remainder) / Policy.EMISSION_SPEED;
  }
}

class ArrayUtils {
  static randomElement(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }
  static subarray(uintarr, begin, end) {
    function clamp(v, min, max) {
      return v < min ? min : v > max ? max : v;
    }
    if (begin === void 0) {
      begin = 0;
    }
    if (end === void 0) {
      end = uintarr.byteLength;
    }
    begin = clamp(begin, 0, uintarr.byteLength);
    end = clamp(end, 0, uintarr.byteLength);
    let len = end - begin;
    if (len < 0) {
      len = 0;
    }
    return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);
  }
  static *k_combinations(list, k) {
    const n = list.length;
    if (k > n) {
      return;
    }
    const indices = Array.from(new Array(k), (x, i) => i);
    yield indices.map((i) => list[i]);
    const reverseRange = Array.from(new Array(k), (x, i) => k - i - 1);
    while (true) {
      let i = k - 1, found = false;
      for (i of reverseRange) {
        if (indices[i] !== i + n - k) {
          found = true;
          break;
        }
      }
      if (!found) {
        return;
      }
      indices[i] += 1;
      for (const j of Array.from(new Array(k - i - 1), (x, k2) => i + k2 + 1)) {
        indices[j] = indices[j - 1] + 1;
      }
      yield indices.map((i2) => list[i2]);
    }
  }
}

class NumberUtils {
  static UINT8_MAX = 255;
  static UINT16_MAX = 65535;
  static UINT32_MAX = 4294967295;
  static UINT64_MAX = Number.MAX_SAFE_INTEGER;
  static isInteger(val) {
    return Number.isInteger(val);
  }
  static isUint8(val) {
    return NumberUtils.isInteger(val) && val >= 0 && val <= NumberUtils.UINT8_MAX;
  }
  static isUint16(val) {
    return NumberUtils.isInteger(val) && val >= 0 && val <= NumberUtils.UINT16_MAX;
  }
  static isUint32(val) {
    return NumberUtils.isInteger(val) && val >= 0 && val <= NumberUtils.UINT32_MAX;
  }
  static isUint64(val) {
    return NumberUtils.isInteger(val) && val >= 0 && val <= NumberUtils.UINT64_MAX;
  }
  static randomUint32() {
    return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));
  }
  static randomUint64() {
    return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));
  }
  static fromBinary(bin) {
    return parseInt(bin, 2);
  }
}

class StringUtils {
  static isMultibyte(str) {
    return /[\uD800-\uDFFF]/.test(str);
  }
  static isHex(str) {
    return /^[0-9A-Fa-f]*$/.test(str);
  }
  static isHexBytes(str, length) {
    if (!StringUtils.isHex(str))
      return false;
    if (str.length % 2 !== 0)
      return false;
    if (typeof length === "number" && str.length / 2 !== length)
      return false;
    return true;
  }
  static commonPrefix(str1, str2) {
    let i = 0;
    for (; i < str1.length; ++i) {
      if (str1[i] !== str2[i])
        break;
    }
    return str1.substring(0, i);
  }
  static lpad(str, padString, length) {
    while (str.length < length)
      str = padString + str;
    return str;
  }
}

class SerialBuffer extends Uint8Array {
  _view;
  _readPos;
  _writePos;
  static EMPTY = new SerialBuffer(0);
  constructor(bufferOrArrayOrLength) {
    super(bufferOrArrayOrLength);
    this._view = new DataView(this.buffer);
    this._readPos = 0;
    this._writePos = 0;
  }
  subarray(start, end) {
    return ArrayUtils.subarray(this, start, end);
  }
  get readPos() {
    return this._readPos;
  }
  set readPos(value) {
    if (value < 0 || value > this.byteLength)
      throw `Invalid readPos ${value}`;
    this._readPos = value;
  }
  get writePos() {
    return this._writePos;
  }
  set writePos(value) {
    if (value < 0 || value > this.byteLength)
      throw `Invalid writePos ${value}`;
    this._writePos = value;
  }
  reset() {
    this._readPos = 0;
    this._writePos = 0;
  }
  read(length) {
    const value = this.subarray(this._readPos, this._readPos + length);
    this._readPos += length;
    return new Uint8Array(value);
  }
  write(array) {
    this.set(array, this._writePos);
    this._writePos += array.byteLength;
  }
  readUint8() {
    return this._view.getUint8(this._readPos++);
  }
  writeUint8(value) {
    this._view.setUint8(this._writePos++, value);
  }
  readUint16() {
    const value = this._view.getUint16(this._readPos);
    this._readPos += 2;
    return value;
  }
  writeUint16(value) {
    this._view.setUint16(this._writePos, value);
    this._writePos += 2;
  }
  readUint32() {
    const value = this._view.getUint32(this._readPos);
    this._readPos += 4;
    return value;
  }
  writeUint32(value) {
    this._view.setUint32(this._writePos, value);
    this._writePos += 4;
  }
  readUint64() {
    const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);
    if (!NumberUtils.isUint64(value))
      throw new Error("Malformed value");
    this._readPos += 8;
    return value;
  }
  writeUint64(value) {
    if (!NumberUtils.isUint64(value))
      throw new Error("Malformed value");
    this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));
    this._view.setUint32(this._writePos + 4, value);
    this._writePos += 8;
  }
  readVarUint() {
    const value = this.readUint8();
    if (value < 253) {
      return value;
    } else if (value === 253) {
      return this.readUint16();
    } else if (value === 254) {
      return this.readUint32();
    } else {
      return this.readUint64();
    }
  }
  writeVarUint(value) {
    if (!NumberUtils.isUint64(value))
      throw new Error("Malformed value");
    if (value < 253) {
      this.writeUint8(value);
    } else if (value <= 65535) {
      this.writeUint8(253);
      this.writeUint16(value);
    } else if (value <= 4294967295) {
      this.writeUint8(254);
      this.writeUint32(value);
    } else {
      this.writeUint8(255);
      this.writeUint64(value);
    }
  }
  static varUintSize(value) {
    if (!NumberUtils.isUint64(value))
      throw new Error("Malformed value");
    if (value < 253) {
      return 1;
    } else if (value <= 65535) {
      return 3;
    } else if (value <= 4294967295) {
      return 5;
    } else {
      return 9;
    }
  }
  readFloat64() {
    const value = this._view.getFloat64(this._readPos);
    this._readPos += 8;
    return value;
  }
  writeFloat64(value) {
    this._view.setFloat64(this._writePos, value);
    this._writePos += 8;
  }
  readString(length) {
    const bytes = this.read(length);
    return BufferUtils.toAscii(bytes);
  }
  writeString(value, length) {
    if (StringUtils.isMultibyte(value) || value.length !== length)
      throw new Error("Malformed value/length");
    const bytes = BufferUtils.fromAscii(value);
    this.write(bytes);
  }
  readPaddedString(length) {
    const bytes = this.read(length);
    let i = 0;
    while (i < length && bytes[i] !== 0)
      i++;
    const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);
    return BufferUtils.toAscii(view);
  }
  writePaddedString(value, length) {
    if (StringUtils.isMultibyte(value) || value.length > length)
      throw new Error("Malformed value/length");
    const bytes = BufferUtils.fromAscii(value);
    this.write(bytes);
    const padding = length - bytes.byteLength;
    this.write(new Uint8Array(padding));
  }
  readVarLengthString() {
    const length = this.readUint8();
    if (this._readPos + length > this.length)
      throw new Error("Malformed length");
    const bytes = this.read(length);
    return BufferUtils.toAscii(bytes);
  }
  writeVarLengthString(value) {
    if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length))
      throw new Error("Malformed value");
    const bytes = BufferUtils.fromAscii(value);
    this.writeUint8(bytes.byteLength);
    this.write(bytes);
  }
  static varLengthStringSize(value) {
    if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length))
      throw new Error("Malformed value");
    return 1 + value.length;
  }
}

class BufferUtils {
  static BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  static BASE32_ALPHABET = {
    RFC4648: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    RFC4648_HEX: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    NIMIQ: "0123456789ABCDEFGHJKLMNPQRSTUVXY"
  };
  static HEX_ALPHABET = "0123456789abcdef";
  static _BASE64_LOOKUP = [];
  static _ISO_8859_15_DECODER;
  static _UTF8_ENCODER;
  static toAscii(buffer) {
    const chunkSize = 8192;
    const buf = BufferUtils._toUint8View(buffer);
    let ascii = "";
    for (let i = 0; i < buf.length; i += chunkSize) {
      ascii += String.fromCharCode.apply(null, [...buf.subarray(i, i + chunkSize)]);
    }
    return ascii;
  }
  static fromAscii(string) {
    const buf = new Uint8Array(string.length);
    for (let i = 0; i < string.length; ++i) {
      buf[i] = string.charCodeAt(i);
    }
    return buf;
  }
  static _codePointTextDecoder(buffer) {
    if (typeof TextDecoder === "undefined")
      throw new Error("TextDecoder not supported");
    if (BufferUtils._ISO_8859_15_DECODER === null)
      throw new Error("TextDecoder does not support iso-8859-15");
    if (BufferUtils._ISO_8859_15_DECODER === void 0) {
      try {
        BufferUtils._ISO_8859_15_DECODER = new TextDecoder("iso-8859-15");
      } catch (e) {
        BufferUtils._ISO_8859_15_DECODER = null;
        throw new Error("TextDecoder does not support iso-8859-15");
      }
    }
    const uint8View = BufferUtils._toUint8View(buffer);
    return BufferUtils._ISO_8859_15_DECODER.decode(uint8View).replace(/\u20ac/g, "\xA4").replace(/\u0160/g, "\xA6").replace(/\u0161/g, "\xA8").replace(/\u017d/g, "\xB4").replace(/\u017e/g, "\xB8").replace(/\u0152/g, "\xBC").replace(/\u0153/g, "\xBD").replace(/\u0178/g, "\xBE");
  }
  static _tripletToBase64(num) {
    return BufferUtils._BASE64_LOOKUP[num >> 18 & 63] + BufferUtils._BASE64_LOOKUP[num >> 12 & 63] + BufferUtils._BASE64_LOOKUP[num >> 6 & 63] + BufferUtils._BASE64_LOOKUP[num & 63];
  }
  static _base64encodeChunk(u8, start, end) {
    let tmp;
    const output = [];
    for (let i = start; i < end; i += 3) {
      tmp = (u8[i] << 16 & 16711680) + (u8[i + 1] << 8 & 65280) + (u8[i + 2] & 255);
      output.push(BufferUtils._tripletToBase64(tmp));
    }
    return output.join("");
  }
  static _base64fromByteArray(u8) {
    let tmp;
    const len = u8.length;
    const extraBytes = len % 3;
    let output = "";
    const parts = [];
    const maxChunkLength = 16383;
    for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(BufferUtils._base64encodeChunk(u8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = u8[len - 1];
      output += BufferUtils._BASE64_LOOKUP[tmp >> 2];
      output += BufferUtils._BASE64_LOOKUP[tmp << 4 & 63];
      output += "==";
    } else if (extraBytes === 2) {
      tmp = (u8[len - 2] << 8) + u8[len - 1];
      output += BufferUtils._BASE64_LOOKUP[tmp >> 10];
      output += BufferUtils._BASE64_LOOKUP[tmp >> 4 & 63];
      output += BufferUtils._BASE64_LOOKUP[tmp << 2 & 63];
      output += "=";
    }
    parts.push(output);
    return parts.join("");
  }
  static toBase64(buffer) {
    if (typeof TextDecoder !== "undefined" && BufferUtils._ISO_8859_15_DECODER !== null) {
      try {
        return btoa(BufferUtils._codePointTextDecoder(buffer));
      } catch (e) {
      }
    }
    return BufferUtils._base64fromByteArray(BufferUtils._toUint8View(buffer));
  }
  static fromBase64(base64, length) {
    const arr = new Uint8Array(atob(base64).split("").map((c) => c.charCodeAt(0)));
    if (length !== void 0 && arr.length !== length)
      throw new Error("Decoded length does not match expected length");
    return new SerialBuffer(arr);
  }
  static toBase64Url(buffer) {
    return BufferUtils.toBase64(buffer).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, ".");
  }
  static fromBase64Url(base64, length) {
    return BufferUtils.fromBase64(base64.replace(/_/g, "/").replace(/-/g, "+").replace(/\./g, "="), length);
  }
  static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {
    let shift = 3, carry = 0, byte, symbol, i, res = "";
    for (i = 0; i < buf.length; i++) {
      byte = buf[i];
      symbol = carry | byte >> shift;
      res += alphabet[symbol & 31];
      if (shift > 5) {
        shift -= 5;
        symbol = byte >> shift;
        res += alphabet[symbol & 31];
      }
      shift = 5 - shift;
      carry = byte << shift;
      shift = 8 - shift;
    }
    if (shift !== 3) {
      res += alphabet[carry & 31];
    }
    while (res.length % 8 !== 0 && alphabet.length === 33) {
      res += alphabet[32];
    }
    return res;
  }
  static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {
    const charmap = {};
    alphabet.toUpperCase().split("").forEach((c, i) => {
      if (!(c in charmap))
        charmap[c] = i;
    });
    let symbol, shift = 8, carry = 0, buf = [];
    base32.toUpperCase().split("").forEach((char) => {
      if (alphabet.length === 33 && char === alphabet[32])
        return;
      symbol = charmap[char] & 255;
      shift -= 5;
      if (shift > 0) {
        carry |= symbol << shift;
      } else if (shift < 0) {
        buf.push(carry | symbol >> -shift);
        shift += 8;
        carry = symbol << shift & 255;
      } else {
        buf.push(carry | symbol);
        shift = 8;
        carry = 0;
      }
    });
    if (shift !== 8 && carry !== 0) {
      buf.push(carry);
    }
    return new Uint8Array(buf);
  }
  static toHex(buffer) {
    let hex = "";
    for (let i = 0; i < buffer.length; i++) {
      const code = buffer[i];
      hex += BufferUtils.HEX_ALPHABET[code >>> 4];
      hex += BufferUtils.HEX_ALPHABET[code & 15];
    }
    return hex;
  }
  static fromHex(hex, length) {
    hex = hex.trim();
    if (!StringUtils.isHexBytes(hex, length))
      throw new Error("String is not an hex string (of matching length)");
    return new SerialBuffer(new Uint8Array((hex.match(/.{2}/g) || []).map((byte) => parseInt(byte, 16))));
  }
  static toBinary(buffer) {
    let bin = "";
    for (let i = 0; i < buffer.length; i++) {
      const code = buffer[i];
      bin += StringUtils.lpad(code.toString(2), "0", 8);
    }
    return bin;
  }
  static _strToUint8Array(str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
      let c = str.charCodeAt(i);
      if (c < 128) {
        out[p++] = c;
      } else if (c < 2048) {
        out[p++] = c >> 6 | 192;
        out[p++] = c & 63 | 128;
      } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        out[p++] = c >> 18 | 240;
        out[p++] = c >> 12 & 63 | 128;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      } else {
        out[p++] = c >> 12 | 224;
        out[p++] = c >> 6 & 63 | 128;
        out[p++] = c & 63 | 128;
      }
    }
    return new Uint8Array(out);
  }
  static _utf8TextEncoder(str) {
    if (typeof TextEncoder === "undefined")
      throw new Error("TextEncoder not supported");
    if (BufferUtils._UTF8_ENCODER === null)
      throw new Error("TextEncoder does not support utf8");
    if (BufferUtils._UTF8_ENCODER === void 0) {
      try {
        BufferUtils._UTF8_ENCODER = new TextEncoder();
      } catch (e) {
        BufferUtils._UTF8_ENCODER = null;
        throw new Error("TextEncoder does not support utf8");
      }
    }
    return BufferUtils._UTF8_ENCODER.encode(str);
  }
  static fromUtf8(str) {
    if (typeof TextEncoder !== "undefined" && BufferUtils._UTF8_ENCODER !== null) {
      try {
        return BufferUtils._utf8TextEncoder(str);
      } catch (e) {
      }
    }
    return BufferUtils._strToUint8Array(str);
  }
  static fromAny(o, length) {
    if (o === "")
      return SerialBuffer.EMPTY;
    if (!o)
      throw new Error("Invalid buffer format");
    if (o instanceof Uint8Array)
      return new SerialBuffer(o);
    try {
      return BufferUtils.fromHex(o, length);
    } catch (e) {
    }
    try {
      return BufferUtils.fromBase64(o, length);
    } catch (e) {
    }
    throw new Error("Invalid buffer format");
  }
  static concatTypedArrays(a, b) {
    const c = new a.constructor(a.length + b.length);
    c.set(a, 0);
    c.set(b, a.length);
    return c;
  }
  static equals(a, b) {
    const viewA = BufferUtils._toUint8View(a);
    const viewB = BufferUtils._toUint8View(b);
    if (viewA.length !== viewB.length)
      return false;
    for (let i = 0; i < viewA.length; i++) {
      if (viewA[i] !== viewB[i])
        return false;
    }
    return true;
  }
  static compare(a, b) {
    if (a.length < b.length)
      return -1;
    if (a.length > b.length)
      return 1;
    for (let i = 0; i < a.length; i++) {
      if (a[i] < b[i])
        return -1;
      if (a[i] > b[i])
        return 1;
    }
    return 0;
  }
  static xor(a, b) {
    const res = new Uint8Array(a.byteLength);
    for (let i = 0; i < a.byteLength; ++i) {
      res[i] = a[i] ^ b[i];
    }
    return res;
  }
  static _toUint8View(arrayLike) {
    if (arrayLike instanceof Uint8Array) {
      return arrayLike;
    } else if (arrayLike instanceof ArrayBuffer) {
      return new Uint8Array(arrayLike);
    } else if (arrayLike.buffer instanceof ArrayBuffer) {
      return new Uint8Array(arrayLike.buffer);
    } else {
      throw new Error("TypedArray or ArrayBuffer required");
    }
  }
}
for (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {
  BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];
}

class Serializable {
  equals(o) {
    return o instanceof Serializable && BufferUtils.equals(this.serialize(), o.serialize());
  }
  compare(o) {
    return BufferUtils.compare(this.serialize(), o.serialize());
  }
  hashCode() {
    return this.toBase64();
  }
  toString() {
    return this.toBase64();
  }
  toBase64() {
    return BufferUtils.toBase64(this.serialize());
  }
  toHex() {
    return BufferUtils.toHex(this.serialize());
  }
}

class Address extends Serializable {
  static CCODE = "NQ";
  static SERIALIZED_SIZE = 20;
  static HEX_SIZE = 40;
  static NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));
  static CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));
  static copy(o) {
    if (!o)
      return o;
    const obj = new Uint8Array(o._obj);
    return new Address(obj);
  }
  static fromHash(hash) {
    return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));
  }
  _obj;
  constructor(arg) {
    super();
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== Address.SERIALIZED_SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static unserialize(buf) {
    return new Address(buf.read(Address.SERIALIZED_SIZE));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  subarray(begin, end) {
    return this._obj.subarray(begin, end);
  }
  get serializedSize() {
    return Address.SERIALIZED_SIZE;
  }
  equals(o) {
    return o instanceof Address && super.equals(o);
  }
  static fromAny(addr) {
    if (addr instanceof Address)
      return addr;
    if (typeof addr === "string")
      return Address.fromString(addr);
    throw new Error("Invalid address format");
  }
  toPlain() {
    return this.toUserFriendlyAddress();
  }
  static fromString(str) {
    try {
      return Address.fromUserFriendlyAddress(str);
    } catch (e) {
    }
    try {
      return Address.fromHex(str);
    } catch (e) {
    }
    try {
      return Address.fromBase64(str);
    } catch (e) {
    }
    throw new Error("Invalid address format");
  }
  static fromBase64(base64) {
    return new Address(BufferUtils.fromBase64(base64));
  }
  static fromHex(hex) {
    return new Address(BufferUtils.fromHex(hex));
  }
  static fromUserFriendlyAddress(str) {
    str = str.replace(/ /g, "");
    if (str.substring(0, 2).toUpperCase() !== Address.CCODE) {
      throw new Error("Invalid Address: Wrong country code");
    }
    if (str.length !== 36) {
      throw new Error("Invalid Address: Should be 36 chars (ignoring spaces)");
    }
    if (Address._ibanCheck(str.substring(4) + str.substring(0, 4)) !== 1) {
      throw new Error("Invalid Address: Checksum invalid");
    }
    return new Address(BufferUtils.fromBase32(str.substring(4)));
  }
  static _ibanCheck(str) {
    const num = str.split("").map((c) => {
      const code = c.toUpperCase().charCodeAt(0);
      return code >= 48 && code <= 57 ? c : (code - 55).toString();
    }).join("");
    let tmp = "";
    for (let i = 0; i < Math.ceil(num.length / 6); i++) {
      tmp = (parseInt(tmp + num.substring(i * 6, i * 6 + 6)) % 97).toString();
    }
    return parseInt(tmp);
  }
  toUserFriendlyAddress(withSpaces = true) {
    const base32 = BufferUtils.toBase32(this.serialize());
    const check = ("00" + (98 - Address._ibanCheck(base32 + Address.CCODE + "00"))).slice(-2);
    let res = Address.CCODE + check + base32;
    if (withSpaces)
      res = res.replace(/.{4}/g, "$& ").trim();
    return res;
  }
}

class Commitment extends Serializable {
  static SIZE = 32;
  static copy(o) {
    if (!o)
      return o;
    return new Commitment(new Uint8Array(o._obj));
  }
  static sum(commitments) {
    return new Commitment(Commitment._commitmentsAggregate(commitments.map((c) => c._obj)));
  }
  _obj;
  constructor(arg) {
    super();
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== Commitment.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static unserialize(buf) {
    return new Commitment(buf.read(Commitment.SIZE));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return Commitment.SIZE;
  }
  equals(o) {
    return o instanceof Commitment && super.equals(o);
  }
  static _commitmentsAggregate(commitments) {
    if (commitments.some((commitment) => commitment.byteLength !== Commitment.SIZE)) {
      throw Error("Wrong buffer size.");
    }
    const concatenatedCommitments = new Uint8Array(commitments.length * Commitment.SIZE);
    for (let i = 0; i < commitments.length; ++i) {
      concatenatedCommitments.set(commitments[i], i * Commitment.SIZE);
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(Commitment.SIZE);
      const wasmInCommitments = Module.stackAlloc(concatenatedCommitments.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInCommitments, concatenatedCommitments.length).set(concatenatedCommitments);
      Module._ed25519_aggregate_commitments(wasmOut, wasmInCommitments, commitments.length);
      const aggCommitments = new Uint8Array(Commitment.SIZE);
      aggCommitments.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, Commitment.SIZE));
      return aggCommitments;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class Hash extends Serializable {
  static SIZE = /* @__PURE__ */ new Map();
  static NULL;
  _obj;
  _algorithm;
  constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {
    if (arg === null) {
      arg = new Uint8Array(Hash.getSize(algorithm));
    } else {
      if (!(arg instanceof Uint8Array))
        throw new Error("Primitive: Invalid type");
      if (arg.length !== Hash.getSize(algorithm))
        throw new Error("Primitive: Invalid length");
    }
    super();
    this._obj = arg;
    this._algorithm = algorithm;
  }
  static light(arr) {
    return Hash.blake2b(arr);
  }
  static blake2b(arr) {
    return new Hash(Hash.computeBlake2b(arr), Hash.Algorithm.BLAKE2B);
  }
  static hard(arr) {
    return Hash.argon2d(arr);
  }
  static async argon2d(arr) {
    return new Hash(await (await CryptoWorker.getInstanceAsync()).computeArgon2d(arr), Hash.Algorithm.ARGON2D);
  }
  static sha256(arr) {
    return new Hash(Hash.computeSha256(arr), Hash.Algorithm.SHA256);
  }
  static sha512(arr) {
    return new Hash(Hash.computeSha512(arr), Hash.Algorithm.SHA512);
  }
  static compute(arr, algorithm) {
    switch (algorithm) {
      case Hash.Algorithm.BLAKE2B:
        return Hash.blake2b(arr);
      case Hash.Algorithm.SHA256:
        return Hash.sha256(arr);
      default:
        throw new Error("Invalid hash algorithm");
    }
  }
  static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {
    return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  subarray(begin, end) {
    return this._obj.subarray(begin, end);
  }
  get serializedSize() {
    return Hash.SIZE.get(this._algorithm);
  }
  get array() {
    return this._obj;
  }
  get algorithm() {
    return this._algorithm;
  }
  equals(o) {
    return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);
  }
  static fromAny(hash, algorithm = Hash.Algorithm.BLAKE2B) {
    if (hash instanceof Hash)
      return hash;
    try {
      return new Hash(BufferUtils.fromAny(hash, Hash.SIZE.get(algorithm)), algorithm);
    } catch (e) {
      throw new Error("Invalid hash format");
    }
  }
  toPlain() {
    return this.toHex();
  }
  static fromBase64(base64) {
    return new Hash(BufferUtils.fromBase64(base64));
  }
  static fromHex(hex) {
    return new Hash(BufferUtils.fromHex(hex));
  }
  static fromPlain(str) {
    return Hash.fromString(str);
  }
  static fromString(str) {
    try {
      return Hash.fromHex(str);
    } catch (e) {
    }
    try {
      return Hash.fromBase64(str);
    } catch (e) {
    }
    throw new Error("Invalid hash format");
  }
  static isHash(o) {
    return o instanceof Hash;
  }
  static getSize(algorithm) {
    const size = Hash.SIZE.get(algorithm);
    if (typeof size !== "number")
      throw new Error("Invalid hash algorithm");
    return size;
  }
  static computeBlake2b(input) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const hashSize = Hash.getSize(Hash.Algorithm.BLAKE2B);
      const wasmOut = Module.stackAlloc(hashSize);
      const wasmIn = Module.stackAlloc(input.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);
      const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);
      if (res !== 0) {
        throw res;
      }
      const hash = new Uint8Array(hashSize);
      hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));
      return hash;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static computeSha256(input) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const hashSize = Hash.getSize(Hash.Algorithm.SHA256);
      const wasmOut = Module.stackAlloc(hashSize);
      const wasmIn = Module.stackAlloc(input.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);
      Module._nimiq_sha256(wasmOut, wasmIn, input.length);
      const hash = new Uint8Array(hashSize);
      hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));
      return hash;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static computeSha512(input) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const hashSize = Hash.getSize(Hash.Algorithm.SHA512);
      const wasmOut = Module.stackAlloc(hashSize);
      const wasmIn = Module.stackAlloc(input.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);
      Module._nimiq_sha512(wasmOut, wasmIn, input.length);
      const hash = new Uint8Array(hashSize);
      hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));
      return hash;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}
((Hash2) => {
  ((Algorithm2) => {
    Algorithm2[Algorithm2["BLAKE2B"] = 1] = "BLAKE2B";
    Algorithm2[Algorithm2["ARGON2D"] = 2] = "ARGON2D";
    Algorithm2[Algorithm2["SHA256"] = 3] = "SHA256";
    Algorithm2[Algorithm2["SHA512"] = 4] = "SHA512";
  })(Hash2.Algorithm || (Hash2.Algorithm = {}));
  ((Algorithm2) => {
    function toString(hashAlgorithm) {
      switch (hashAlgorithm) {
        case 1 /* BLAKE2B */:
          return "blake2b";
        case 2 /* ARGON2D */:
          return "argon2d";
        case 3 /* SHA256 */:
          return "sha256";
        case 4 /* SHA512 */:
          return "sha512";
        default:
          throw new Error("Invalid hash algorithm");
      }
    }
    Algorithm2.toString = toString;
    function fromAny(algorithm) {
      if (typeof algorithm === "number" && Hash2.SIZE.has(algorithm))
        return algorithm;
      switch (algorithm) {
        case "blake2b":
          return 1 /* BLAKE2B */;
        case "argon2d":
          return 2 /* ARGON2D */;
        case "sha256":
          return 3 /* SHA256 */;
        case "sha512":
          return 4 /* SHA512 */;
        default:
          throw new Error("Invalid hash algorithm");
      }
    }
    Algorithm2.fromAny = fromAny;
  })(Hash2.Algorithm || (Hash2.Algorithm = {}));
})(Hash || (Hash = {}));
Hash.SIZE.set(1 /* BLAKE2B */, 32);
Hash.SIZE.set(2 /* ARGON2D */, 32);
Hash.SIZE.set(3 /* SHA256 */, 32);
Hash.SIZE.set(4 /* SHA512 */, 64);
Hash.NULL = new Hash(new Uint8Array(32));

class CryptoWorker {
  static _workerAsync = null;
  static async getInstanceAsync() {
    if (!CryptoWorker._workerAsync) {
      CryptoWorker._workerAsync = new CryptoWorkerImpl();
    }
    return CryptoWorker._workerAsync;
  }
}
class CryptoWorkerImpl extends CryptoWorker {
  async computeArgon2d(input) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);
      const wasmOut = Module.stackAlloc(hashSize);
      const wasmIn = Module.stackAlloc(input.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);
      const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);
      if (res !== 0) {
        throw res;
      }
      const hash = new Uint8Array(hashSize);
      hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));
      return hash;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  async computeArgon2dBatch(inputs) {
    const hashes = [];
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);
      const wasmOut = Module.stackAlloc(hashSize);
      const stackTmp = Module.stackSave();
      for (const input of inputs) {
        Module.stackRestore(stackTmp);
        const wasmIn = Module.stackAlloc(input.length);
        new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);
        const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);
        if (res !== 0) {
          throw res;
        }
        const hash = new Uint8Array(hashSize);
        hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));
        hashes.push(hash);
      }
      return hashes;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  async kdfLegacy(key, salt, iterations, outputSize = Hash.getSize(Hash.Algorithm.ARGON2D)) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(outputSize);
      const wasmIn = Module.stackAlloc(key.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);
      const wasmSalt = Module.stackAlloc(salt.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);
      const res = Module._nimiq_kdf_legacy(wasmOut, outputSize, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);
      if (res !== 0) {
        throw res;
      }
      const hash = new Uint8Array(outputSize);
      hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, outputSize));
      return hash;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  async kdf(key, salt, iterations, outputSize = Hash.getSize(Hash.Algorithm.ARGON2D)) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(outputSize);
      const wasmIn = Module.stackAlloc(key.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);
      const wasmSalt = Module.stackAlloc(salt.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);
      const res = Module._nimiq_kdf(wasmOut, outputSize, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);
      if (res !== 0) {
        throw res;
      }
      const hash = new Uint8Array(outputSize);
      hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, outputSize));
      return hash;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class CryptoUtils {
  static SHA512_BLOCK_SIZE = 128;
  static getRandomValues(buf) {
    if (typeof window !== "undefined") {
      return window.crypto.getRandomValues(buf);
    } else {
      const crypto = require("crypto");
      if (!(buf instanceof Uint8Array)) {
        throw new TypeError("expected Uint8Array");
      }
      if (buf.length > 65536) {
        const e = new Error();
        e.message = `Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length ${buf.length} exceeds the number of bytes of entropy available via this API (65536).`;
        e.name = "QuotaExceededError";
        throw e;
      }
      const bytes = crypto.randomBytes(buf.length);
      buf.set(bytes);
      return buf;
    }
  }
  static computeHmacSha512(key, data) {
    if (key.length > CryptoUtils.SHA512_BLOCK_SIZE) {
      key = new SerialBuffer(Hash.computeSha512(key));
    }
    const iKey = new SerialBuffer(CryptoUtils.SHA512_BLOCK_SIZE);
    const oKey = new SerialBuffer(CryptoUtils.SHA512_BLOCK_SIZE);
    for (let i = 0; i < CryptoUtils.SHA512_BLOCK_SIZE; ++i) {
      const byte = key[i] || 0;
      iKey[i] = 54 ^ byte;
      oKey[i] = 92 ^ byte;
    }
    const innerHash = Hash.computeSha512(BufferUtils.concatTypedArrays(iKey, data));
    return Hash.computeSha512(BufferUtils.concatTypedArrays(oKey, innerHash));
  }
  static computePBKDF2sha512(password, salt, iterations, derivedKeyLength) {
    const hashLength = Hash.SIZE.get(Hash.Algorithm.SHA512);
    if (derivedKeyLength > (Math.pow(2, 32) - 1) * hashLength) {
      throw new Error("Derived key too long");
    }
    const l = Math.ceil(derivedKeyLength / hashLength);
    const r = derivedKeyLength - (l - 1) * hashLength;
    const derivedKey = new SerialBuffer(derivedKeyLength);
    for (let i = 1; i <= l; i++) {
      let u1 = new SerialBuffer(salt.length + 4);
      u1.write(salt);
      u1.writeUint32(i);
      let u2 = CryptoUtils.computeHmacSha512(password, u1);
      const t = u2;
      for (let j = 1; j < iterations; j++) {
        u2 = CryptoUtils.computeHmacSha512(password, u2);
        for (let k = 0; k < t.length; k++) {
          t[k] ^= u2[k];
        }
      }
      if (i < l) {
        derivedKey.write(t);
      } else {
        derivedKey.write(t.slice(0, r));
      }
    }
    return derivedKey;
  }
  static async otpKdfLegacy(message, key, salt, iterations) {
    const worker = await CryptoWorker.getInstanceAsync();
    const derivedKey = await worker.kdfLegacy(key, salt, iterations, message.byteLength);
    return BufferUtils.xor(message, derivedKey);
  }
  static async otpKdf(message, key, salt, iterations) {
    const worker = await CryptoWorker.getInstanceAsync();
    const derivedKey = await worker.kdf(key, salt, iterations, message.byteLength);
    return BufferUtils.xor(message, derivedKey);
  }
}

class CRC8 {
  static _table = null;
  static _createTable() {
    const table = [];
    for (let i = 0; i < 256; ++i) {
      let curr = i;
      for (let j = 0; j < 8; ++j) {
        if ((curr & 128) !== 0) {
          curr = (curr << 1 ^ 151) % 256;
        } else {
          curr = (curr << 1) % 256;
        }
      }
      table[i] = curr;
    }
    return table;
  }
  static compute(buf) {
    if (!CRC8._table)
      CRC8._table = CRC8._createTable();
    let c = 0;
    for (let i = 0; i < buf.length; i++) {
      c = CRC8._table[(c ^ buf[i]) % 256];
    }
    return c;
  }
}

class PublicKey extends Serializable {
  static SIZE = 32;
  static copy(o) {
    if (!o)
      return o;
    return new PublicKey(new Uint8Array(o._obj));
  }
  _obj;
  constructor(arg) {
    super();
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== PublicKey.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static derive(privateKey) {
    return new PublicKey(PublicKey._publicKeyDerive(privateKey.serialize()));
  }
  static sum(publicKeys) {
    publicKeys = publicKeys.slice();
    publicKeys.sort((a, b) => a.compare(b));
    return PublicKey._delinearizeAndAggregatePublicKeys(publicKeys);
  }
  static unserialize(buf) {
    return new PublicKey(buf.read(PublicKey.SIZE));
  }
  static fromAny(o) {
    if (!o)
      throw new Error("Invalid public key format");
    if (o instanceof PublicKey)
      return o;
    try {
      return new PublicKey(BufferUtils.fromAny(o, PublicKey.SIZE));
    } catch (e) {
      throw new Error("Invalid public key format");
    }
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return PublicKey.SIZE;
  }
  equals(o) {
    return o instanceof PublicKey && super.equals(o);
  }
  hash() {
    return Hash.blake2b(this.serialize());
  }
  compare(o) {
    return BufferUtils.compare(this._obj, o._obj);
  }
  toAddress() {
    return Address.fromHash(this.hash());
  }
  static _delinearizeAndAggregatePublicKeys(publicKeys) {
    const publicKeysObj = publicKeys.map((k) => k.serialize());
    const publicKeysHash = PublicKey._publicKeysHash(publicKeysObj);
    const raw = PublicKey._publicKeysDelinearizeAndAggregate(publicKeysObj, publicKeysHash);
    return new PublicKey(raw);
  }
  static _publicKeyDerive(privateKey) {
    if (privateKey.byteLength !== PrivateKey.SIZE) {
      throw Error("Wrong buffer size.");
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(PublicKey.SIZE);
      const pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOut, PrivateKey.SIZE);
      pubKeyBuffer.set(privateKey);
      const wasmIn = Module.stackAlloc(privateKey.length);
      const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmIn, PrivateKey.SIZE);
      privKeyBuffer.set(privateKey);
      Module._ed25519_public_key_derive(wasmOut, wasmIn);
      privKeyBuffer.fill(0);
      const publicKey = new Uint8Array(PublicKey.SIZE);
      publicKey.set(pubKeyBuffer);
      return publicKey;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static _publicKeysHash(publicKeys) {
    if (publicKeys.some((publicKey) => publicKey.byteLength !== PublicKey.SIZE)) {
      throw Error("Wrong buffer size.");
    }
    const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);
    for (let i = 0; i < publicKeys.length; ++i) {
      concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const hashSize = Hash.getSize(Hash.Algorithm.SHA512);
      const wasmOut = Module.stackAlloc(hashSize);
      const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);
      Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);
      const hashedPublicKey = new Uint8Array(hashSize);
      hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));
      return hashedPublicKey;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static _publicKeyDelinearize(publicKey, publicKeysHash) {
    if (publicKey.byteLength !== PublicKey.SIZE || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {
      throw Error("Wrong buffer size.");
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(PublicKey.SIZE);
      const wasmInPublicKey = Module.stackAlloc(publicKey.length);
      const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);
      Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);
      const delinearizedPublicKey = new Uint8Array(PublicKey.SIZE);
      delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));
      return delinearizedPublicKey;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static _publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {
    if (publicKeys.some((publicKey) => publicKey.byteLength !== PublicKey.SIZE) || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {
      throw Error("Wrong buffer size.");
    }
    const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);
    for (let i = 0; i < publicKeys.length; ++i) {
      concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(PublicKey.SIZE);
      const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);
      const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);
      Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);
      const aggregatePublicKey = new Uint8Array(PublicKey.SIZE);
      aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));
      return aggregatePublicKey;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class Secret extends Serializable {
  _type;
  _purposeId;
  static SIZE = 32;
  static ENCRYPTION_SALT_SIZE = 16;
  static ENCRYPTION_KDF_ROUNDS = 256;
  static ENCRYPTION_CHECKSUM_SIZE = 4;
  static ENCRYPTION_CHECKSUM_SIZE_V3 = 2;
  constructor(type, purposeId) {
    super();
    this._type = type;
    this._purposeId = purposeId;
  }
  static async fromEncrypted(buf, key) {
    const version = buf.readUint8();
    const roundsLog = buf.readUint8();
    if (roundsLog > 32)
      throw new Error("Rounds out-of-bounds");
    const rounds = Math.pow(2, roundsLog);
    switch (version) {
      case 1:
        return Secret._decryptV1(buf, key, rounds);
      case 2:
        return Secret._decryptV2(buf, key, rounds);
      case 3:
        return Secret._decryptV3(buf, key, rounds);
      default:
        throw new Error("Unsupported version");
    }
  }
  static async _decryptV1(buf, key, rounds) {
    const ciphertext = buf.read(Secret.SIZE);
    const salt = buf.read(Secret.ENCRYPTION_SALT_SIZE);
    const check = buf.read(Secret.ENCRYPTION_CHECKSUM_SIZE);
    const plaintext = await CryptoUtils.otpKdfLegacy(ciphertext, key, salt, rounds);
    const privateKey = new PrivateKey(plaintext);
    const publicKey = PublicKey.derive(privateKey);
    const checksum = publicKey.hash().subarray(0, Secret.ENCRYPTION_CHECKSUM_SIZE);
    if (!BufferUtils.equals(check, checksum)) {
      throw new Error("Invalid key");
    }
    return privateKey;
  }
  static async _decryptV2(buf, key, rounds) {
    const ciphertext = buf.read(Secret.SIZE);
    const salt = buf.read(Secret.ENCRYPTION_SALT_SIZE);
    const check = buf.read(Secret.ENCRYPTION_CHECKSUM_SIZE);
    const plaintext = await CryptoUtils.otpKdfLegacy(ciphertext, key, salt, rounds);
    const checksum = Hash.computeBlake2b(plaintext).subarray(0, Secret.ENCRYPTION_CHECKSUM_SIZE);
    if (!BufferUtils.equals(check, checksum)) {
      throw new Error("Invalid key");
    }
    return new PrivateKey(plaintext);
  }
  static async _decryptV3(buf, key, rounds) {
    const salt = buf.read(Secret.ENCRYPTION_SALT_SIZE);
    const ciphertext = buf.read(Secret.ENCRYPTION_CHECKSUM_SIZE_V3 + 4 + Secret.SIZE);
    const plaintext = await CryptoUtils.otpKdf(ciphertext, key, salt, rounds);
    const check = plaintext.subarray(0, Secret.ENCRYPTION_CHECKSUM_SIZE_V3);
    const payload = plaintext.subarray(Secret.ENCRYPTION_CHECKSUM_SIZE_V3);
    const checksum = Hash.computeBlake2b(payload).subarray(0, Secret.ENCRYPTION_CHECKSUM_SIZE_V3);
    if (!BufferUtils.equals(check, checksum)) {
      throw new Error("Invalid key");
    }
    const purposeId = payload[0] << 24 | payload[1] << 16 | payload[2] << 8 | payload[3];
    const secret = payload.subarray(4);
    switch (purposeId) {
      case PrivateKey.PURPOSE_ID:
        return new PrivateKey(secret);
      case Entropy.PURPOSE_ID:
      default:
        return new Entropy(secret);
    }
  }
  async exportEncrypted(key) {
    const salt = new Uint8Array(Secret.ENCRYPTION_SALT_SIZE);
    CryptoUtils.getRandomValues(salt);
    const data = new SerialBuffer(4 + Secret.SIZE);
    data.writeUint32(this._purposeId);
    data.write(this.serialize());
    const checksum = Hash.computeBlake2b(data).subarray(0, Secret.ENCRYPTION_CHECKSUM_SIZE_V3);
    const plaintext = new SerialBuffer(checksum.byteLength + data.byteLength);
    plaintext.write(checksum);
    plaintext.write(data);
    const ciphertext = await CryptoUtils.otpKdf(plaintext, key, salt, Secret.ENCRYPTION_KDF_ROUNDS);
    const buf = new SerialBuffer(1 + 1 + salt.byteLength + ciphertext.byteLength);
    buf.writeUint8(3);
    buf.writeUint8(Math.log2(Secret.ENCRYPTION_KDF_ROUNDS));
    buf.write(salt);
    buf.write(ciphertext);
    return buf;
  }
  get encryptedSize() {
    return 1 + 1 + Secret.ENCRYPTION_SALT_SIZE + Secret.ENCRYPTION_CHECKSUM_SIZE_V3 + 4 + Secret.SIZE;
  }
  get type() {
    return this._type;
  }
}
((Secret2) => {
  ((Type2) => {
    Type2[Type2["PRIVATE_KEY"] = 1] = "PRIVATE_KEY";
    Type2[Type2["ENTROPY"] = 2] = "ENTROPY";
  })(Secret2.Type || (Secret2.Type = {}));
})(Secret || (Secret = {}));

class PrivateKey extends Secret {
  static SIZE = Secret.SIZE;
  static PURPOSE_ID = 1107296257;
  _obj;
  constructor(arg) {
    super(Secret.Type.PRIVATE_KEY, PrivateKey.PURPOSE_ID);
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== PrivateKey.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static generate() {
    const privateKey = new Uint8Array(PrivateKey.SIZE);
    CryptoUtils.getRandomValues(privateKey);
    return new PrivateKey(privateKey);
  }
  static unserialize(buf) {
    return new PrivateKey(buf.read(PrivateKey.SIZE));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return PrivateKey.SIZE;
  }
  overwrite(privateKey) {
    this._obj.set(privateKey._obj);
  }
  equals(o) {
    return o instanceof PrivateKey && super.equals(o);
  }
  static _privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {
    if (privateKey.byteLength !== PrivateKey.SIZE || publicKey.byteLength !== PublicKey.SIZE || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {
      throw Error("Wrong buffer size.");
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(PublicKey.SIZE);
      const wasmInPrivateKey = Module.stackAlloc(privateKey.length);
      const wasmInPublicKey = Module.stackAlloc(publicKey.length);
      const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);
      Module._ed25519_derive_delinearized_private_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey, wasmInPrivateKey);
      const delinearizedPrivateKey = new Uint8Array(PrivateKey.SIZE);
      delinearizedPrivateKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PrivateKey.SIZE));
      return delinearizedPrivateKey;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class ExtendedPrivateKey extends Serializable {
  static CHAIN_CODE_SIZE = 32;
  _key;
  _chainCode;
  constructor(key, chainCode) {
    super();
    if (!(key instanceof PrivateKey))
      throw new Error("ExtendedPrivateKey: Invalid key");
    if (!(chainCode instanceof Uint8Array))
      throw new Error("ExtendedPrivateKey: Invalid chainCode");
    if (chainCode.length !== ExtendedPrivateKey.CHAIN_CODE_SIZE)
      throw new Error("ExtendedPrivateKey: Invalid chainCode length");
    this._key = key;
    this._chainCode = chainCode;
  }
  static generateMasterKey(seed) {
    const bCurve = BufferUtils.fromAscii("ed25519 seed");
    const hash = CryptoUtils.computeHmacSha512(bCurve, seed);
    return new ExtendedPrivateKey(new PrivateKey(hash.slice(0, 32)), hash.slice(32));
  }
  derive(index) {
    if (index < 2147483648)
      index += 2147483648;
    const data = new SerialBuffer(1 + PrivateKey.SIZE + 4);
    data.writeUint8(0);
    this._key.serialize(data);
    data.writeUint32(index);
    const hash = CryptoUtils.computeHmacSha512(this._chainCode, data);
    return new ExtendedPrivateKey(new PrivateKey(hash.slice(0, 32)), hash.slice(32));
  }
  static isValidPath(path) {
    if (path.match(/^m(\/[0-9]+')*$/) === null)
      return false;
    const segments = path.split("/");
    for (let i = 1; i < segments.length; i++) {
      if (!NumberUtils.isUint32(parseInt(segments[i])))
        return false;
    }
    return true;
  }
  derivePath(path) {
    if (!ExtendedPrivateKey.isValidPath(path))
      throw new Error("Invalid path");
    let extendedKey = this;
    const segments = path.split("/");
    for (let i = 1; i < segments.length; i++) {
      const index = parseInt(segments[i]);
      extendedKey = extendedKey.derive(index);
    }
    return extendedKey;
  }
  static derivePathFromSeed(path, seed) {
    let extendedKey = ExtendedPrivateKey.generateMasterKey(seed);
    return extendedKey.derivePath(path);
  }
  static unserialize(buf) {
    const privateKey = PrivateKey.unserialize(buf);
    const chainCode = buf.read(ExtendedPrivateKey.CHAIN_CODE_SIZE);
    return new ExtendedPrivateKey(privateKey, chainCode);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    this._key.serialize(buf);
    buf.write(this._chainCode);
    return buf;
  }
  get serializedSize() {
    return this._key.serializedSize + ExtendedPrivateKey.CHAIN_CODE_SIZE;
  }
  equals(o) {
    return o instanceof ExtendedPrivateKey && super.equals(o);
  }
  get privateKey() {
    return this._key;
  }
  toAddress() {
    return PublicKey.derive(this._key).toAddress();
  }
}

class MnemonicUtils {
  static ENGLISH_WORDLIST;
  static DEFAULT_WORDLIST;
  static _crcChecksum(entropy) {
    const ENT = entropy.length * 8;
    const CS = ENT / 32;
    const hash = CRC8.compute(entropy);
    return BufferUtils.toBinary([hash]).slice(0, CS);
  }
  static _sha256Checksum(entropy) {
    const ENT = entropy.length * 8;
    const CS = ENT / 32;
    const hash = Hash.computeSha256(entropy);
    return BufferUtils.toBinary(hash).slice(0, CS);
  }
  static _entropyToBits(entropy) {
    if (entropy.length < 16)
      throw new Error("Invalid key, length < 16");
    if (entropy.length > 32)
      throw new Error("Invalid key, length > 32");
    if (entropy.length % 4 !== 0)
      throw new Error("Invalid key, length % 4 != 0");
    return BufferUtils.toBinary(entropy);
  }
  static _normalizeEntropy(entropy) {
    let normalized;
    if (typeof entropy === "string")
      normalized = BufferUtils.fromHex(entropy);
    else if (entropy instanceof Entropy)
      normalized = entropy.serialize();
    else if (entropy instanceof ArrayBuffer)
      normalized = new Uint8Array(entropy);
    else
      normalized = entropy;
    return normalized;
  }
  static _bitsToMnemonic(bits, wordlist) {
    const chunks = bits.match(/(.{11})/g);
    if (!chunks)
      throw new Error("Invalid bits, less than 11 characters");
    const words = chunks.map((chunk) => {
      const index = NumberUtils.fromBinary(chunk);
      return wordlist[index];
    });
    return words;
  }
  static _mnemonicToBits(mnemonic, wordlist) {
    const words = mnemonic;
    if (words.length < 12)
      throw new Error("Invalid mnemonic, less than 12 words");
    if (words.length > 24)
      throw new Error("Invalid mnemonic, more than 24 words");
    if (words.length % 3 !== 0)
      throw new Error("Invalid mnemonic, words % 3 != 0");
    const bits = words.map(function(word) {
      const index = wordlist.indexOf(word.toLowerCase());
      if (index === -1)
        throw new Error(`Invalid mnemonic, word >${word}< is not in wordlist`);
      return StringUtils.lpad(index.toString(2), "0", 11);
    }).join("");
    return bits;
  }
  static _bitsToEntropy(bits, legacy = false) {
    const dividerIndex = bits.length - (bits.length % 8 || 8);
    const entropyBits = bits.slice(0, dividerIndex);
    const checksumBits = bits.slice(dividerIndex);
    const chunks = entropyBits.match(/(.{8})/g);
    if (!chunks)
      throw new Error("Invalid entropyBits, less than 8 characters");
    const entropyBytes = chunks.map(NumberUtils.fromBinary);
    if (entropyBytes.length < 16)
      throw new Error("Invalid generated key, length < 16");
    if (entropyBytes.length > 32)
      throw new Error("Invalid generated key, length > 32");
    if (entropyBytes.length % 4 !== 0)
      throw new Error("Invalid generated key, length % 4 != 0");
    const entropy = new Uint8Array(entropyBytes);
    const checksum = legacy ? MnemonicUtils._crcChecksum(entropy) : MnemonicUtils._sha256Checksum(entropy);
    if (checksum !== checksumBits)
      throw new Error("Invalid checksum");
    return entropy;
  }
  static entropyToMnemonic(entropy, wordlist) {
    wordlist = wordlist || MnemonicUtils.DEFAULT_WORDLIST;
    const normalized = MnemonicUtils._normalizeEntropy(entropy);
    const entropyBits = MnemonicUtils._entropyToBits(normalized);
    const checksumBits = MnemonicUtils._sha256Checksum(normalized);
    const bits = entropyBits + checksumBits;
    return MnemonicUtils._bitsToMnemonic(bits, wordlist);
  }
  static entropyToLegacyMnemonic(entropy, wordlist) {
    wordlist = wordlist || MnemonicUtils.DEFAULT_WORDLIST;
    const normalized = MnemonicUtils._normalizeEntropy(entropy);
    const entropyBits = MnemonicUtils._entropyToBits(normalized);
    const checksumBits = MnemonicUtils._crcChecksum(normalized);
    const bits = entropyBits + checksumBits;
    return MnemonicUtils._bitsToMnemonic(bits, wordlist);
  }
  static mnemonicToEntropy(mnemonic, wordlist) {
    if (!Array.isArray(mnemonic))
      mnemonic = mnemonic.trim().split(/\s+/g);
    wordlist = wordlist || MnemonicUtils.DEFAULT_WORDLIST;
    const bits = MnemonicUtils._mnemonicToBits(mnemonic, wordlist);
    return new Entropy(MnemonicUtils._bitsToEntropy(bits, false));
  }
  static legacyMnemonicToEntropy(mnemonic, wordlist) {
    if (!Array.isArray(mnemonic))
      mnemonic = mnemonic.trim().split(/\s+/g);
    wordlist = wordlist || MnemonicUtils.DEFAULT_WORDLIST;
    const bits = MnemonicUtils._mnemonicToBits(mnemonic, wordlist);
    return new Entropy(MnemonicUtils._bitsToEntropy(bits, true));
  }
  static _salt(password) {
    return `mnemonic${password || ""}`;
  }
  static mnemonicToSeed(mnemonic, password) {
    if (Array.isArray(mnemonic))
      mnemonic = mnemonic.join(" ");
    const mnemonicBuffer = BufferUtils.fromAscii(mnemonic);
    const saltBuffer = BufferUtils.fromAscii(MnemonicUtils._salt(password));
    return CryptoUtils.computePBKDF2sha512(mnemonicBuffer, saltBuffer, 2048, 64);
  }
  static mnemonicToExtendedPrivateKey(mnemonic, password) {
    const seed = MnemonicUtils.mnemonicToSeed(mnemonic, password);
    return ExtendedPrivateKey.generateMasterKey(seed);
  }
  static isCollidingChecksum(entropy) {
    const normalizedEntropy = MnemonicUtils._normalizeEntropy(entropy);
    return MnemonicUtils._crcChecksum(normalizedEntropy) === MnemonicUtils._sha256Checksum(normalizedEntropy);
  }
  static getMnemonicType(mnemonic, wordlist) {
    if (!Array.isArray(mnemonic))
      mnemonic = mnemonic.trim().split(/\s+/g);
    wordlist = wordlist || MnemonicUtils.DEFAULT_WORDLIST;
    const bits = MnemonicUtils._mnemonicToBits(mnemonic, wordlist);
    let isBIP39 = true;
    try {
      MnemonicUtils._bitsToEntropy(bits, false);
    } catch (e) {
      isBIP39 = false;
    }
    let isLegacy = true;
    try {
      MnemonicUtils._bitsToEntropy(bits, true);
    } catch (e) {
      isLegacy = false;
    }
    if (isBIP39 && isLegacy)
      return MnemonicUtils.MnemonicType.UNKNOWN;
    if (!isBIP39 && !isLegacy)
      throw new Error("Invalid checksum");
    return isBIP39 ? MnemonicUtils.MnemonicType.BIP39 : MnemonicUtils.MnemonicType.LEGACY;
  }
}
MnemonicUtils.ENGLISH_WORDLIST = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];
MnemonicUtils.DEFAULT_WORDLIST = MnemonicUtils.ENGLISH_WORDLIST;
((MnemonicUtils2) => {
  ((MnemonicType2) => {
    MnemonicType2[MnemonicType2["UNKNOWN"] = -1] = "UNKNOWN";
    MnemonicType2[MnemonicType2["LEGACY"] = 0] = "LEGACY";
    MnemonicType2[MnemonicType2["BIP39"] = 1] = "BIP39";
  })(MnemonicUtils2.MnemonicType || (MnemonicUtils2.MnemonicType = {}));
})(MnemonicUtils || (MnemonicUtils = {}));
Object.freeze(MnemonicUtils);

class Entropy extends Secret {
  static SIZE = Secret.SIZE;
  static PURPOSE_ID = 1107296258;
  _obj;
  constructor(arg) {
    super(Secret.Type.ENTROPY, Entropy.PURPOSE_ID);
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== Entropy.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static generate() {
    const entropy = new Uint8Array(Entropy.SIZE);
    CryptoUtils.getRandomValues(entropy);
    return new Entropy(entropy);
  }
  toExtendedPrivateKey(password, wordlist) {
    return MnemonicUtils.mnemonicToExtendedPrivateKey(this.toMnemonic(wordlist), password);
  }
  toMnemonic(wordlist) {
    return MnemonicUtils.entropyToMnemonic(this, wordlist);
  }
  static unserialize(buf) {
    return new Entropy(buf.read(Entropy.SIZE));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return Entropy.SIZE;
  }
  overwrite(entropy) {
    this._obj.set(entropy._obj);
  }
  equals(o) {
    return o instanceof Entropy && super.equals(o);
  }
}

class KeyPair extends Serializable {
  static LOCK_KDF_ROUNDS = 256;
  _locked;
  _lockedInternally;
  _lockSalt;
  _publicKey;
  _internalPrivateKey;
  _unlockedPrivateKey = null;
  constructor(privateKey, publicKey, locked = false, lockSalt = null) {
    if (!(privateKey instanceof Object))
      throw new Error("Primitive: Invalid type");
    if (!(publicKey instanceof Object))
      throw new Error("Primitive: Invalid type");
    super();
    this._locked = locked;
    this._lockedInternally = locked;
    this._lockSalt = lockSalt;
    this._publicKey = publicKey;
    this._internalPrivateKey = new PrivateKey(privateKey.serialize());
  }
  static generate() {
    const privateKey = PrivateKey.generate();
    return new KeyPair(privateKey, PublicKey.derive(privateKey));
  }
  static derive(privateKey) {
    return new KeyPair(privateKey, PublicKey.derive(privateKey));
  }
  static fromHex(hexBuf) {
    return KeyPair.unserialize(BufferUtils.fromHex(hexBuf));
  }
  static unserialize(buf) {
    const privateKey = PrivateKey.unserialize(buf);
    const publicKey = PublicKey.unserialize(buf);
    let locked = false;
    let lockSalt = null;
    if (buf.readPos < buf.byteLength) {
      const extra = buf.readUint8();
      if (extra === 1) {
        locked = true;
        lockSalt = buf.read(32);
      }
    }
    return new KeyPair(privateKey, publicKey, locked, lockSalt);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    this._privateKey.serialize(buf);
    this.publicKey.serialize(buf);
    if (this._locked) {
      buf.writeUint8(1);
      buf.write(this._lockSalt);
    } else {
      buf.writeUint8(0);
    }
    return buf;
  }
  get privateKey() {
    if (this.isLocked)
      throw new Error("KeyPair is locked");
    return this._privateKey;
  }
  get _privateKey() {
    return this._unlockedPrivateKey || this._internalPrivateKey;
  }
  get publicKey() {
    return this._publicKey;
  }
  get serializedSize() {
    return this._privateKey.serializedSize + this.publicKey.serializedSize + (this._locked ? this._lockSalt.byteLength + 1 : 1);
  }
  async lock(key, lockSalt) {
    if (this._locked)
      throw new Error("KeyPair already locked");
    if (lockSalt)
      this._lockSalt = lockSalt;
    if (!this._lockSalt || this._lockSalt.length === 0) {
      this._lockSalt = new Uint8Array(32);
      CryptoUtils.getRandomValues(this._lockSalt);
    }
    this._internalPrivateKey.overwrite(await this._otpPrivateKey(key));
    this._clearUnlockedPrivateKey();
    this._locked = true;
    this._lockedInternally = true;
  }
  async unlock(key) {
    if (!this._locked)
      throw new Error("KeyPair not locked");
    const privateKey = await this._otpPrivateKey(key);
    const verifyPub = PublicKey.derive(privateKey);
    if (verifyPub.equals(this.publicKey)) {
      this._unlockedPrivateKey = privateKey;
      this._locked = false;
    } else {
      throw new Error("Invalid key");
    }
  }
  relock() {
    if (this._locked)
      throw new Error("KeyPair already locked");
    if (!this._lockedInternally)
      throw new Error("KeyPair was never locked");
    this._clearUnlockedPrivateKey();
    this._locked = true;
  }
  _clearUnlockedPrivateKey() {
    if (!this._lockedInternally || this._locked)
      return;
    if (!this._unlockedPrivateKey)
      throw new Error("No unlocked private key to clear");
    this._unlockedPrivateKey.overwrite(PrivateKey.unserialize(new SerialBuffer(this._unlockedPrivateKey.serializedSize)));
    this._unlockedPrivateKey = null;
  }
  async _otpPrivateKey(key) {
    return new PrivateKey(await CryptoUtils.otpKdfLegacy(this._privateKey.serialize(), key, this._lockSalt, KeyPair.LOCK_KDF_ROUNDS));
  }
  get isLocked() {
    return this._locked;
  }
  static async fromEncrypted(buf, key) {
    const privateKey = await Secret.fromEncrypted(buf, key);
    if (privateKey.type !== Secret.Type.PRIVATE_KEY)
      throw new Error("Expected privateKey, got Entropy");
    return KeyPair.derive(privateKey);
  }
  exportEncrypted(key) {
    return this._privateKey.exportEncrypted(key);
  }
  get encryptedSize() {
    return this._privateKey.encryptedSize;
  }
  equals(o) {
    return o instanceof KeyPair && super.equals(o);
  }
}

class MerkleTree {
  static computeRoot(values, fnHash = MerkleTree.hash) {
    return MerkleTree._computeRoot(values, fnHash);
  }
  static _computeRoot(values, fnHash) {
    const len = values.length;
    if (len === 0) {
      return Hash.light(new Uint8Array(0));
    }
    if (len === 1) {
      return fnHash(values[0]);
    }
    const mid = Math.round(len / 2);
    const left = values.slice(0, mid);
    const right = values.slice(mid);
    const leftHash = MerkleTree._computeRoot(left, fnHash);
    const rightHash = MerkleTree._computeRoot(right, fnHash);
    return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));
  }
  static hash(o) {
    if (o instanceof Hash) {
      return o;
    }
    if ("hash" in o && typeof o.hash === "function") {
      return o.hash();
    }
    if ("serialize" in o && typeof o.serialize === "function") {
      return Hash.light(o.serialize());
    }
    if (o instanceof Uint8Array) {
      return Hash.light(o);
    }
    throw new Error("MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method");
  }
}

class MerklePath {
  _nodes;
  constructor(nodes) {
    if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length) || nodes.some((it) => !(it instanceof MerklePathNode)))
      throw new Error("Malformed nodes");
    this._nodes = nodes;
  }
  static compute(values, leafValue, fnHash = MerkleTree.hash) {
    const leafHash = fnHash(leafValue);
    const path = [];
    MerklePath._compute(values, leafHash, path, fnHash);
    return new MerklePath(path);
  }
  static _compute(values, leafHash, path, fnHash) {
    const len = values.length;
    let hash;
    if (len === 0) {
      hash = Hash.light(new Uint8Array(0));
      return { containsLeaf: false, inner: hash };
    }
    if (len === 1) {
      hash = fnHash(values[0]);
      return { containsLeaf: hash.equals(leafHash), inner: hash };
    }
    const mid = Math.round(len / 2);
    const left = values.slice(0, mid);
    const right = values.slice(mid);
    const { containsLeaf: leftLeaf, inner: leftHash } = MerklePath._compute(left, leafHash, path, fnHash);
    const { containsLeaf: rightLeaf, inner: rightHash } = MerklePath._compute(right, leafHash, path, fnHash);
    hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));
    if (leftLeaf) {
      path.push(new MerklePathNode(rightHash, false));
      return { containsLeaf: true, inner: hash };
    } else if (rightLeaf) {
      path.push(new MerklePathNode(leftHash, true));
      return { containsLeaf: true, inner: hash };
    }
    return { containsLeaf: false, inner: hash };
  }
  computeRoot(leafValue, fnHash = MerkleTree.hash) {
    let root = fnHash(leafValue);
    for (const node of this._nodes) {
      const left = node.left;
      const hash = node.hash;
      const concat = new SerialBuffer(hash.serializedSize * 2);
      if (left)
        hash.serialize(concat);
      root.serialize(concat);
      if (!left)
        hash.serialize(concat);
      root = Hash.light(concat);
    }
    return root;
  }
  static _compress(nodes) {
    const count = nodes.length;
    const leftBitsSize = Math.ceil(count / 8);
    const leftBits = new Uint8Array(leftBitsSize);
    for (let i = 0; i < count; i++) {
      if (nodes[i].left) {
        leftBits[Math.floor(i / 8)] |= 128 >>> i % 8;
      }
    }
    return leftBits;
  }
  static unserialize(buf) {
    const count = buf.readUint8();
    const leftBitsSize = Math.ceil(count / 8);
    const leftBits = buf.read(leftBitsSize);
    const nodes = [];
    for (let i = 0; i < count; i++) {
      const left = (leftBits[Math.floor(i / 8)] & 128 >>> i % 8) !== 0;
      const hash = Hash.unserialize(buf);
      nodes.push(new MerklePathNode(hash, left));
    }
    return new MerklePath(nodes);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.writeUint8(this._nodes.length);
    buf.write(MerklePath._compress(this._nodes));
    for (const node of this._nodes) {
      node.hash.serialize(buf);
    }
    return buf;
  }
  get serializedSize() {
    const leftBitsSize = Math.ceil(this._nodes.length / 8);
    return 1 + leftBitsSize + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);
  }
  equals(o) {
    return o instanceof MerklePath && this._nodes.length === o._nodes.length && this._nodes.every((node, i) => node.equals(o._nodes[i]));
  }
  get nodes() {
    return this._nodes;
  }
}
class MerklePathNode {
  _hash;
  _left;
  constructor(hash, left) {
    this._hash = hash;
    this._left = left;
  }
  get hash() {
    return this._hash;
  }
  get left() {
    return this._left;
  }
  equals(o) {
    return o instanceof MerklePathNode && this._hash.equals(o.hash) && this._left === o.left;
  }
}

class Account {
  static TYPE_MAP = /* @__PURE__ */ new Map();
  static INITIAL;
  static BalanceError = class extends Error {
    constructor() {
      super("Balance Error!");
    }
  };
  static DoubleTransactionError = class extends Error {
    constructor() {
      super("Double Transaction Error!");
    }
  };
  static ProofError = class extends Error {
    constructor() {
      super("Proof Error!");
    }
  };
  static ValidityError = class extends Error {
    constructor() {
      super("Validity Error!");
    }
  };
  _type;
  _balance;
  constructor(type, balance) {
    if (!NumberUtils.isUint8(type))
      throw new Error("Malformed type");
    if (!NumberUtils.isUint64(balance))
      throw new Error("Malformed balance");
    this._type = type;
    this._balance = balance;
  }
  static unserialize(buf) {
    const type = buf.readUint8();
    buf.readPos--;
    if (!Account.TYPE_MAP.has(type)) {
      throw new Error("Unknown account type");
    }
    return Account.TYPE_MAP.get(type).unserialize(buf);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.writeUint8(this._type);
    buf.writeUint64(this._balance);
    return buf;
  }
  get serializedSize() {
    return 1 + 8;
  }
  equals(o) {
    return o instanceof Account && BufferUtils.equals(this.serialize(), o.serialize());
  }
  toString() {
    return `Account{type=${this._type}, balance=${this._balance.toString()}`;
  }
  static fromAny(o) {
    if (o instanceof Account)
      return o;
    return Account.fromPlain(o);
  }
  static fromPlain(plain) {
    if (!plain || plain.type === void 0)
      throw new Error("Invalid account");
    const type = Account.Type.fromAny(plain.type);
    return Account.TYPE_MAP.get(type).fromPlain(plain);
  }
  toPlain() {
    return {
      type: Account.Type.toString(this.type),
      balance: this.balance
    };
  }
  get balance() {
    return this._balance;
  }
  get type() {
    return this._type;
  }
  withBalance(balance) {
    throw new Error("Not yet implemented.");
  }
  withIncomingTransaction(transaction, blockHeight, revert = false) {
    if (!revert) {
      return this.withBalance(this._balance + transaction.value);
    } else {
      const newBalance = this._balance - transaction.value;
      if (newBalance < 0) {
        throw new Account.BalanceError();
      }
      return this.withBalance(newBalance);
    }
  }
  withContractCommand(transaction, blockHeight, revert = false) {
    throw new Error("Not yet implemented");
  }
  isInitial() {
    return this === Account.INITIAL;
  }
  isToBePruned() {
    return this._balance === 0 && !this.isInitial();
  }
  static dataToPlain(data) {
    return {};
  }
  static proofToPlain(proof) {
    return {};
  }
}
((Account2) => {
  ((Type2) => {
    Type2[Type2["BASIC"] = 0] = "BASIC";
    Type2[Type2["VESTING"] = 1] = "VESTING";
    Type2[Type2["HTLC"] = 2] = "HTLC";
  })(Account2.Type || (Account2.Type = {}));
  ((Type2) => {
    function toString(type) {
      switch (type) {
        case 0 /* BASIC */:
          return "basic";
        case 1 /* VESTING */:
          return "vesting";
        case 2 /* HTLC */:
          return "htlc";
        default:
          throw new Error("Invalid account type");
      }
    }
    Type2.toString = toString;
    function fromAny(type) {
      if (typeof type === "number")
        return type;
      switch (type) {
        case "basic":
          return 0 /* BASIC */;
        case "vesting":
          return 1 /* VESTING */;
        case "htlc":
          return 2 /* HTLC */;
        default:
          throw new Error("Invalid account type");
      }
    }
    Type2.fromAny = fromAny;
  })(Account2.Type || (Account2.Type = {}));
})(Account || (Account = {}));

class RandomSecret extends Serializable {
  static SIZE = 32;
  _obj;
  constructor(arg) {
    super();
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== RandomSecret.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static unserialize(buf) {
    return new RandomSecret(buf.read(RandomSecret.SIZE));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return RandomSecret.SIZE;
  }
  equals(o) {
    return o instanceof RandomSecret && super.equals(o);
  }
}

class PartialSignature extends Serializable {
  static SIZE = 32;
  _obj;
  constructor(arg) {
    super();
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== PartialSignature.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static create(privateKey, publicKey, publicKeys, secret, aggregateCommitment, data) {
    const raw = PartialSignature._delinearizedPartialSignatureCreate(
      publicKeys.map((o) => o.serialize()),
      privateKey.serialize(),
      publicKey.serialize(),
      secret.serialize(),
      aggregateCommitment.serialize(),
      data
    );
    return new PartialSignature(raw);
  }
  static unserialize(buf) {
    return new PartialSignature(buf.read(PartialSignature.SIZE));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return PartialSignature.SIZE;
  }
  equals(o) {
    return o instanceof PartialSignature && super.equals(o);
  }
  static _delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {
    if (publicKeys.some((publicKey2) => publicKey2.byteLength !== PublicKey.SIZE) || privateKey.byteLength !== PrivateKey.SIZE || publicKey.byteLength !== PublicKey.SIZE || secret.byteLength !== RandomSecret.SIZE || aggregateCommitment.byteLength !== Commitment.SIZE) {
      throw Error("Wrong buffer size.");
    }
    const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);
    for (let i = 0; i < publicKeys.length; ++i) {
      concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOut = Module.stackAlloc(PartialSignature.SIZE);
      const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);
      const wasmInPrivateKey = Module.stackAlloc(privateKey.length);
      const wasmInPublicKey = Module.stackAlloc(publicKey.length);
      const wasmInSecret = Module.stackAlloc(secret.length);
      const wasmInCommitment = Module.stackAlloc(aggregateCommitment.length);
      const wasmInMessage = Module.stackAlloc(message.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);
      new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);
      new Uint8Array(Module.HEAPU8.buffer, wasmInSecret, secret.length).set(secret);
      new Uint8Array(Module.HEAPU8.buffer, wasmInCommitment, aggregateCommitment.length).set(aggregateCommitment);
      new Uint8Array(Module.HEAPU8.buffer, wasmInMessage, message.length).set(message);
      Module._ed25519_delinearized_partial_sign(wasmOut, wasmInMessage, message.length, wasmInCommitment, wasmInSecret, wasmInPublicKeys, publicKeys.length, wasmInPublicKey, wasmInPrivateKey);
      const partialSignature = new Uint8Array(PartialSignature.SIZE);
      partialSignature.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PartialSignature.SIZE));
      return partialSignature;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class Signature extends Serializable {
  static SIZE = 64;
  static copy(o) {
    if (!o)
      return o;
    const obj = new Uint8Array(o._obj);
    return new Signature(obj);
  }
  _obj;
  constructor(arg) {
    super();
    if (!(arg instanceof Uint8Array))
      throw new Error("Primitive: Invalid type");
    if (arg.length !== Signature.SIZE)
      throw new Error("Primitive: Invalid length");
    this._obj = arg;
  }
  static create(privateKey, publicKey, data) {
    return new Signature(Signature._signatureCreate(privateKey.serialize(), publicKey.serialize(), data));
  }
  static fromPartialSignatures(commitment, signatures) {
    const raw = Signature._combinePartialSignatures(commitment.serialize(), signatures.map((s) => s.serialize()));
    return new Signature(raw);
  }
  static unserialize(buf) {
    return new Signature(buf.read(Signature.SIZE));
  }
  static fromAny(o) {
    if (!o)
      throw new Error("Invalid signature format");
    if (o instanceof Signature)
      return o;
    try {
      return new Signature(BufferUtils.fromAny(o, Signature.SIZE));
    } catch (e) {
      throw new Error("Invalid signature format");
    }
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.write(this._obj);
    return buf;
  }
  get serializedSize() {
    return Signature.SIZE;
  }
  verify(publicKey, data) {
    return Signature._signatureVerify(publicKey.serialize(), data, this._obj);
  }
  equals(o) {
    return o instanceof Signature && super.equals(o);
  }
  static _combinePartialSignatures(combinedCommitment, partialSignatures) {
    const combinedSignature = Signature._aggregatePartialSignatures(partialSignatures);
    return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);
  }
  static _aggregatePartialSignatures(partialSignatures) {
    return partialSignatures.reduce((sigA, sigB) => Signature._scalarsAdd(sigA, sigB));
  }
  static _scalarsAdd(a, b) {
    if (a.byteLength !== PartialSignature.SIZE || b.byteLength !== PartialSignature.SIZE) {
      throw Error("Wrong buffer size.");
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOutSum = Module.stackAlloc(PartialSignature.SIZE);
      const wasmInA = Module.stackAlloc(a.length);
      const wasmInB = Module.stackAlloc(b.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);
      new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);
      Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);
      const sum = new Uint8Array(PartialSignature.SIZE);
      sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, PartialSignature.SIZE));
      return sum;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static _signatureCreate(privateKey, publicKey, message) {
    if (publicKey.byteLength !== PublicKey.SIZE || privateKey.byteLength !== PrivateKey.SIZE) {
      throw Error("Wrong buffer size.");
    }
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOutSignature = Module.stackAlloc(Signature.SIZE);
      const signatureBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOutSignature, Signature.SIZE);
      const wasmInMessage = Module.stackAlloc(message.length);
      new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);
      const wasmInPubKey = Module.stackAlloc(publicKey.length);
      new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);
      const wasmInPrivKey = Module.stackAlloc(privateKey.length);
      const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmInPrivKey, privateKey.length);
      privKeyBuffer.set(privateKey);
      Module._ed25519_sign(wasmOutSignature, wasmInMessage, message.byteLength, wasmInPubKey, wasmInPrivKey);
      privKeyBuffer.fill(0);
      const signature = new Uint8Array(Signature.SIZE);
      signature.set(signatureBuffer);
      return signature;
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
  static _signatureVerify(publicKey, message, signature) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmInPubKey = Module.stackAlloc(publicKey.length);
      new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);
      const wasmInMessage = Module.stackAlloc(message.length);
      new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);
      const wasmInSignature = Module.stackAlloc(signature.length);
      new Uint8Array(Module.HEAP8.buffer, wasmInSignature, signature.length).set(signature);
      return !!Module._ed25519_verify(wasmInSignature, wasmInMessage, message.byteLength, wasmInPubKey);
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class CommitmentPair extends Serializable {
  static SERIALIZED_SIZE = RandomSecret.SIZE + Signature.SIZE;
  static RANDOMNESS_SIZE = 32;
  _secret;
  _commitment;
  constructor(secret, commitment) {
    super();
    if (!(secret instanceof RandomSecret))
      throw new Error("Primitive: Invalid type");
    if (!(commitment instanceof Commitment))
      throw new Error("Primitive: Invalid type");
    this._secret = secret;
    this._commitment = commitment;
  }
  static generate() {
    const randomness = new Uint8Array(CommitmentPair.RANDOMNESS_SIZE);
    CryptoUtils.getRandomValues(randomness);
    const raw = CommitmentPair._commitmentCreate(randomness);
    return new CommitmentPair(new RandomSecret(raw.secret), new Commitment(raw.commitment));
  }
  static unserialize(buf) {
    const secret = RandomSecret.unserialize(buf);
    const commitment = Commitment.unserialize(buf);
    return new CommitmentPair(secret, commitment);
  }
  static fromHex(hexBuf) {
    return this.unserialize(BufferUtils.fromHex(hexBuf));
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    this.secret.serialize(buf);
    this.commitment.serialize(buf);
    return buf;
  }
  get secret() {
    return this._secret;
  }
  get commitment() {
    return this._commitment;
  }
  get serializedSize() {
    return this.secret.serializedSize + this.commitment.serializedSize;
  }
  equals(o) {
    return o instanceof CommitmentPair && super.equals(o);
  }
  static _commitmentCreate(randomness) {
    const Module = WasmHelper.Module;
    let stackPtr;
    try {
      stackPtr = Module.stackSave();
      const wasmOutCommitment = Module.stackAlloc(Commitment.SIZE);
      const wasmOutSecret = Module.stackAlloc(Commitment.SIZE);
      const wasmIn = Module.stackAlloc(randomness.length);
      new Uint8Array(Module.HEAPU8.buffer, wasmIn, randomness.length).set(randomness);
      const res = Module._ed25519_create_commitment(wasmOutSecret, wasmOutCommitment, wasmIn);
      if (res !== 1) {
        throw new Error(`Secret must not be 0 or 1: ${res}`);
      }
      const commitment = new Uint8Array(Commitment.SIZE);
      const secret = new Uint8Array(Commitment.SIZE);
      commitment.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutCommitment, Commitment.SIZE));
      secret.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSecret, Commitment.SIZE));
      return { commitment, secret };
    } catch (e) {
      throw e;
    } finally {
      if (stackPtr !== void 0)
        Module.stackRestore(stackPtr);
    }
  }
}

class Assert {
  static that(condition, message = "Assertion failed") {
    if (!condition) {
      throw new Error(message);
    }
  }
}

class Transaction {
  static FORMAT_MAP = /* @__PURE__ */ new Map();
  _format;
  _sender;
  _senderType;
  _recipient;
  _recipientType;
  _value;
  _fee;
  _networkId;
  _validityStartHeight;
  _flags;
  _data;
  _proof;
  _valid;
  _hash;
  constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId = GenesisConfig.NETWORK_ID) {
    if (!(sender instanceof Address))
      throw new Error("Malformed sender");
    if (!NumberUtils.isUint8(senderType))
      throw new Error("Malformed sender type");
    if (!(recipient instanceof Address))
      throw new Error("Malformed recipient");
    if (!NumberUtils.isUint8(recipientType))
      throw new Error("Malformed recipient type");
    if (!NumberUtils.isUint64(value) || value === 0)
      throw new Error("Malformed value");
    if (!NumberUtils.isUint64(fee))
      throw new Error("Malformed fee");
    if (!NumberUtils.isUint32(validityStartHeight))
      throw new Error("Malformed validityStartHeight");
    if (!NumberUtils.isUint8(flags) && (flags & ~Transaction.Flag.ALL) > 0)
      throw new Error("Malformed flags");
    if (!(data instanceof Uint8Array) || !NumberUtils.isUint16(data.byteLength))
      throw new Error("Malformed data");
    if (!(proof instanceof Uint8Array) || !NumberUtils.isUint16(proof.byteLength))
      throw new Error("Malformed proof");
    if (!NumberUtils.isUint8(networkId))
      throw new Error("Malformed networkId");
    this._format = format;
    this._sender = sender;
    this._senderType = senderType;
    this._recipient = recipient;
    this._recipientType = recipientType;
    this._value = value;
    this._fee = fee;
    this._networkId = networkId;
    this._validityStartHeight = validityStartHeight;
    this._flags = flags;
    this._data = data;
    this._proof = proof;
    if (this._recipient === Address.CONTRACT_CREATION)
      this._recipient = this.getContractCreationAddress();
  }
  static unserialize(buf) {
    const format = buf.readUint8();
    buf.readPos--;
    if (!Transaction.FORMAT_MAP.has(format))
      throw new Error("Invalid transaction type");
    return Transaction.FORMAT_MAP.get(format).unserialize(buf);
  }
  serializeContent(buf) {
    buf = buf || new SerialBuffer(this.serializedContentSize);
    buf.writeUint16(this._data.byteLength);
    buf.write(this._data);
    this._sender.serialize(buf);
    buf.writeUint8(this._senderType);
    this._recipient.serialize(buf);
    buf.writeUint8(this._recipientType);
    buf.writeUint64(this._value);
    buf.writeUint64(this._fee);
    buf.writeUint32(this._validityStartHeight);
    buf.writeUint8(this._networkId);
    buf.writeUint8(this._flags);
    return buf;
  }
  get serializedContentSize() {
    return 2 + this._data.byteLength + this._sender.serializedSize + 1 + this._recipient.serializedSize + 1 + 8 + 8 + 4 + 1 + 1;
  }
  verify(networkId) {
    if (this._valid === void 0) {
      this._valid = this._verify(networkId);
    }
    return this._valid;
  }
  _verify(networkId = GenesisConfig.NETWORK_ID) {
    if (this._networkId !== networkId) {
      return false;
    }
    if (this._recipient.equals(this._sender)) {
      return false;
    }
    if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {
      return false;
    }
    if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {
      return false;
    }
    if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {
      return false;
    }
    return true;
  }
  get serializedSize() {
    throw new Error("Getter needs to be overwritten by subclasses");
  }
  serialize(buf) {
    throw new Error("Method needs to be overwritten by subclasses");
  }
  hash() {
    this._hash = this._hash || Hash.light(this.serializeContent());
    return this._hash;
  }
  compare(o) {
    if (this.fee / this.serializedSize > o.fee / o.serializedSize)
      return -1;
    if (this.fee / this.serializedSize < o.fee / o.serializedSize)
      return 1;
    if (this.serializedSize > o.serializedSize)
      return -1;
    if (this.serializedSize < o.serializedSize)
      return 1;
    if (this.fee > o.fee)
      return -1;
    if (this.fee < o.fee)
      return 1;
    if (this.value > o.value)
      return -1;
    if (this.value < o.value)
      return 1;
    return this.compareBlockOrder(o);
  }
  compareBlockOrder(o) {
    const recCompare = this._recipient.compare(o._recipient);
    if (recCompare !== 0)
      return recCompare;
    if (this._validityStartHeight < o._validityStartHeight)
      return -1;
    if (this._validityStartHeight > o._validityStartHeight)
      return 1;
    if (this._fee > o._fee)
      return -1;
    if (this._fee < o._fee)
      return 1;
    if (this._value > o._value)
      return -1;
    if (this._value < o._value)
      return 1;
    const senderCompare = this._sender.compare(o._sender);
    if (senderCompare !== 0)
      return senderCompare;
    if (this._recipientType < o._recipientType)
      return -1;
    if (this._recipientType > o._recipientType)
      return 1;
    if (this._senderType < o._senderType)
      return -1;
    if (this._senderType > o._senderType)
      return 1;
    if (this._flags < o._flags)
      return -1;
    if (this._flags > o._flags)
      return 1;
    return BufferUtils.compare(this._data, o._data);
  }
  equals(o) {
    return o instanceof Transaction && this._sender.equals(o._sender) && this._senderType === o._senderType && this._recipient.equals(o._recipient) && this._recipientType === o._recipientType && this._value === o._value && this._fee === o._fee && this._validityStartHeight === o._validityStartHeight && this._networkId === o._networkId && this._flags === o._flags && BufferUtils.equals(this._data, o._data);
  }
  toString() {
    return `Transaction{sender=${this._sender.toBase64()}, recipient=${this._recipient.toBase64()}, value=${this._value}, fee=${this._fee}, validityStartHeight=${this._validityStartHeight}, networkId=${this._networkId}}`;
  }
  toPlain() {
    const data = Account.TYPE_MAP.get(this.recipientType).dataToPlain(this.data);
    data.raw = BufferUtils.toHex(this.data);
    const proof = Account.TYPE_MAP.get(this.senderType).proofToPlain(this.proof);
    proof.raw = BufferUtils.toHex(this.proof);
    return {
      transactionHash: this.hash().toPlain(),
      format: Transaction.Format.toString(this._format),
      sender: this.sender.toPlain(),
      senderType: Account.Type.toString(this.senderType),
      recipient: this.recipient.toPlain(),
      recipientType: Account.Type.toString(this.recipientType),
      value: this.value,
      fee: this.fee,
      feePerByte: this.feePerByte,
      validityStartHeight: this.validityStartHeight,
      network: GenesisConfig.networkIdToNetworkName(this.networkId),
      flags: this.flags,
      data,
      proof,
      size: this.serializedSize,
      valid: this.verify()
    };
  }
  static fromPlain(plain) {
    if (!plain)
      throw new Error("Invalid transaction format");
    const format = Transaction.Format.fromAny(plain.format);
    if (!Transaction.FORMAT_MAP.has(format))
      throw new Error("Invalid transaction type");
    return Transaction.FORMAT_MAP.get(format).fromPlain(plain);
  }
  static fromAny(tx) {
    if (tx instanceof Transaction)
      return tx;
    if (typeof tx === "object")
      return Transaction.fromPlain(tx);
    if (typeof tx === "string")
      return Transaction.unserialize(new SerialBuffer(BufferUtils.fromHex(tx)));
    throw new Error("Invalid transaction format");
  }
  getContractCreationAddress() {
    const tx = Transaction.unserialize(this.serialize());
    tx._recipient = Address.NULL;
    tx._hash = void 0;
    return Address.fromHash(tx.hash());
  }
  get format() {
    return this._format;
  }
  get sender() {
    return this._sender;
  }
  get senderType() {
    return this._senderType;
  }
  get recipient() {
    return this._recipient;
  }
  get recipientType() {
    return this._recipientType;
  }
  get value() {
    return this._value;
  }
  get fee() {
    return this._fee;
  }
  get feePerByte() {
    return this._fee / this.serializedSize;
  }
  get networkId() {
    return this._networkId;
  }
  get validityStartHeight() {
    return this._validityStartHeight;
  }
  get flags() {
    return this._flags;
  }
  hasFlag(flag) {
    return (this._flags & flag) > 0;
  }
  get data() {
    return this._data;
  }
  get proof() {
    return this._proof;
  }
  set proof(proof) {
    this._proof = proof;
  }
}
((Transaction2) => {
  ((Format2) => {
    Format2[Format2["BASIC"] = 0] = "BASIC";
    Format2[Format2["EXTENDED"] = 1] = "EXTENDED";
  })(Transaction2.Format || (Transaction2.Format = {}));
  ((Format2) => {
    function toString(format) {
      switch (format) {
        case 0 /* BASIC */:
          return "basic";
        case 1 /* EXTENDED */:
          return "extended";
        default:
          throw new Error("Invalid transaction format");
      }
    }
    Format2.toString = toString;
    function fromAny(format) {
      if (typeof format === "number")
        return format;
      switch (format) {
        case "basic":
          return 0 /* BASIC */;
        case "extended":
          return 1 /* EXTENDED */;
        default:
          throw new Error("Invalid transaction format");
      }
    }
    Format2.fromAny = fromAny;
  })(Transaction2.Format || (Transaction2.Format = {}));
  ((Flag2) => {
    Flag2[Flag2["NONE"] = 0] = "NONE";
    Flag2[Flag2["CONTRACT_CREATION"] = 1] = "CONTRACT_CREATION";
    Flag2[Flag2["ALL"] = 1] = "ALL";
  })(Transaction2.Flag || (Transaction2.Flag = {}));
})(Transaction || (Transaction = {}));

class ExtendedTransaction extends Transaction {
  constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0), networkId) {
    super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);
  }
  static unserialize(buf) {
    const type = buf.readUint8();
    Assert.that(type === Transaction.Format.EXTENDED);
    const dataSize = buf.readUint16();
    const data = buf.read(dataSize);
    const sender = Address.unserialize(buf);
    const senderType = buf.readUint8();
    const recipient = Address.unserialize(buf);
    const recipientType = buf.readUint8();
    const value = buf.readUint64();
    const fee = buf.readUint64();
    const validityStartHeight = buf.readUint32();
    const networkId = buf.readUint8();
    const flags = buf.readUint8();
    const proofSize = buf.readUint16();
    const proof = buf.read(proofSize);
    return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);
  }
  static fromPlain(plain) {
    if (!plain)
      throw new Error("Invalid transaction format");
    return new ExtendedTransaction(
      Address.fromAny(plain.sender),
      Account.Type.fromAny(plain.senderType),
      Address.fromAny(plain.recipient),
      Account.Type.fromAny(plain.recipientType),
      plain.value,
      plain.fee,
      plain.validityStartHeight,
      plain.flags,
      BufferUtils.fromAny(plain.data.raw === void 0 ? plain.data : plain.data.raw),
      BufferUtils.fromAny(plain.proof.raw === void 0 ? plain.proof : plain.proof.raw),
      GenesisConfig.networkIdFromAny(plain.network || plain.networkId)
    );
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.writeUint8(Transaction.Format.EXTENDED);
    this.serializeContent(buf);
    buf.writeUint16(this._proof.byteLength);
    buf.write(this._proof);
    return buf;
  }
  get serializedSize() {
    return 1 + this.serializedContentSize + 2 + this._proof.byteLength;
  }
}
Transaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);

class SignatureProof {
  static verifyTransaction(transaction) {
    if (!transaction.proof)
      return false;
    try {
      const buffer = new SerialBuffer(transaction.proof);
      const proof = SignatureProof.unserialize(buffer);
      if (buffer.readPos !== buffer.byteLength) {
        return false;
      }
      return proof.verify(transaction.sender, transaction.serializeContent());
    } catch (e) {
      return false;
    }
  }
  static singleSig(publicKey, signature) {
    return new SignatureProof(publicKey, new MerklePath([]), signature);
  }
  static multiSig(signerKey, publicKeys, signature) {
    const merklePath = MerklePath.compute(publicKeys, signerKey);
    return new SignatureProof(signerKey, merklePath, signature);
  }
  _publicKey;
  _merklePath;
  _signature;
  constructor(publicKey, merklePath, signature) {
    if (!(publicKey instanceof PublicKey))
      throw new Error("Malformed publickKey");
    if (!(merklePath instanceof MerklePath))
      throw new Error("Malformed merklePath");
    if (signature && !(signature instanceof Signature))
      throw new Error("Malformed signature");
    this._publicKey = publicKey;
    this._merklePath = merklePath;
    this._signature = signature;
  }
  static unserialize(buf) {
    const publicKey = PublicKey.unserialize(buf);
    const merklePath = MerklePath.unserialize(buf);
    const signature = Signature.unserialize(buf);
    return new SignatureProof(publicKey, merklePath, signature);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    this._publicKey.serialize(buf);
    this._merklePath.serialize(buf);
    if (this._signature) {
      this._signature.serialize(buf);
    }
    return buf;
  }
  get serializedSize() {
    return this._publicKey.serializedSize + this._merklePath.serializedSize + (this._signature ? this._signature.serializedSize : 0);
  }
  static get SINGLE_SIG_SIZE() {
    return PublicKey.SIZE + new MerklePath([]).serializedSize + Signature.SIZE;
  }
  equals(o) {
    return o instanceof SignatureProof && this._publicKey.equals(o._publicKey) && this._merklePath.equals(o._merklePath) && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);
  }
  verify(sender, data) {
    if (sender !== null && !this.isSignedBy(sender)) {
      return false;
    }
    if (!this._signature) {
      return false;
    }
    if (!this._signature.verify(this._publicKey, data)) {
      return false;
    }
    return true;
  }
  isSignedBy(sender) {
    const merkleRoot = this._merklePath.computeRoot(this._publicKey);
    const signerAddr = Address.fromHash(merkleRoot);
    return signerAddr.equals(sender);
  }
  get publicKey() {
    return this._publicKey;
  }
  get merklePath() {
    return this._merklePath;
  }
  get signature() {
    return this._signature;
  }
  set signature(signature) {
    this._signature = signature;
  }
}

class BasicTransaction extends Transaction {
  _signatureProof;
  constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId) {
    if (!(senderPubKey instanceof PublicKey))
      throw new Error("Malformed senderPubKey");
    if (signature !== void 0 && !(signature instanceof Signature))
      throw new Error("Malformed signature");
    const proof = SignatureProof.singleSig(senderPubKey, signature);
    super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize(), networkId);
    this._signatureProof = proof;
  }
  static unserialize(buf) {
    const type = buf.readUint8();
    Assert.that(type === Transaction.Format.BASIC);
    const senderPubKey = PublicKey.unserialize(buf);
    const recipient = Address.unserialize(buf);
    const value = buf.readUint64();
    const fee = buf.readUint64();
    const validityStartHeight = buf.readUint32();
    const networkId = buf.readUint8();
    const signature = Signature.unserialize(buf);
    return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId);
  }
  static fromPlain(plain) {
    if (!plain)
      throw new Error("Invalid transaction format");
    return new BasicTransaction(
      PublicKey.fromAny(plain.proof.publicKey || plain.senderPubKey),
      Address.fromAny(plain.recipient),
      plain.value,
      plain.fee,
      plain.validityStartHeight,
      Signature.fromAny(plain.proof.signature || plain.signature),
      GenesisConfig.networkIdFromAny(plain.network || plain.networkId)
    );
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    buf.writeUint8(Transaction.Format.BASIC);
    this.senderPubKey.serialize(buf);
    this._recipient.serialize(buf);
    buf.writeUint64(this._value);
    buf.writeUint64(this._fee);
    buf.writeUint32(this._validityStartHeight);
    buf.writeUint8(this._networkId);
    if (this.signature)
      this.signature.serialize(buf);
    return buf;
  }
  get serializedSize() {
    return 1 + this.senderPubKey.serializedSize + this._recipient.serializedSize + 8 + 8 + 4 + 1 + (this.signature ? this.signature.serializedSize : 0);
  }
  get senderPubKey() {
    return this._signatureProof.publicKey;
  }
  get signature() {
    return this._signatureProof.signature;
  }
  set signature(signature) {
    this._signatureProof.signature = signature;
    this._proof = this._signatureProof.serialize();
  }
}
Transaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);

class Wallet {
  static generate() {
    return new Wallet(KeyPair.generate());
  }
  static loadPlain(buf) {
    if (typeof buf === "string")
      buf = BufferUtils.fromHex(buf);
    if (!buf || buf.byteLength === 0) {
      throw new Error("Invalid wallet seed");
    }
    return new Wallet(KeyPair.unserialize(new SerialBuffer(buf)));
  }
  static async loadEncrypted(buf, key) {
    if (typeof buf === "string")
      buf = BufferUtils.fromHex(buf);
    if (typeof key === "string")
      key = BufferUtils.fromUtf8(key);
    return new Wallet(await KeyPair.fromEncrypted(new SerialBuffer(buf), key));
  }
  _keyPair;
  _address;
  constructor(keyPair) {
    this._keyPair = keyPair;
    this._address = this._keyPair.publicKey.toAddress();
  }
  createTransaction(recipient, value, fee, validityStartHeight) {
    const transaction = new BasicTransaction(this._keyPair.publicKey, recipient, value, fee, validityStartHeight);
    transaction.signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());
    return transaction;
  }
  signTransaction(transaction) {
    const signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());
    return SignatureProof.singleSig(this._keyPair.publicKey, signature);
  }
  exportPlain() {
    return this._keyPair.serialize();
  }
  exportEncrypted(key) {
    if (typeof key === "string")
      key = BufferUtils.fromUtf8(key);
    return this._keyPair.exportEncrypted(key);
  }
  get isLocked() {
    return this.keyPair.isLocked;
  }
  lock(key) {
    if (typeof key === "string")
      key = BufferUtils.fromUtf8(key);
    return this.keyPair.lock(key);
  }
  relock() {
    this.keyPair.relock();
  }
  unlock(key) {
    if (typeof key === "string")
      key = BufferUtils.fromUtf8(key);
    return this.keyPair.unlock(key);
  }
  equals(o) {
    return o instanceof Wallet && this.keyPair.equals(o.keyPair) && this.address.equals(o.address);
  }
  get address() {
    return this._address;
  }
  get publicKey() {
    return this._keyPair.publicKey;
  }
  get keyPair() {
    return this._keyPair;
  }
}

class MultiSigWallet extends Wallet {
  static fromPublicKeys(keyPair, minSignatures, publicKeys) {
    if (publicKeys.length === 0)
      throw new Error("publicKeys may not be empty");
    if (minSignatures <= 0)
      throw new Error("minSignatures must be greater than 0");
    if (!publicKeys.some((key) => key.equals(keyPair.publicKey)))
      throw new Error("Own publicKey must be part of publicKeys");
    publicKeys = publicKeys.slice();
    publicKeys.sort((a, b) => a.compare(b));
    const combinations = [...ArrayUtils.k_combinations(publicKeys, minSignatures)];
    const multiSigKeys = combinations.map((arr) => PublicKey.sum(arr));
    return new MultiSigWallet(keyPair, minSignatures, multiSigKeys);
  }
  static _loadMultiSig(keyPair, buf) {
    const minSignatures = buf.readUint8();
    const numPublicKeys = buf.readUint8();
    const publicKeys = [];
    for (let i = 0; i < numPublicKeys; ++i) {
      publicKeys.push(PublicKey.unserialize(buf));
    }
    return new MultiSigWallet(keyPair, minSignatures, publicKeys);
  }
  static loadPlain(buf) {
    if (typeof buf === "string")
      buf = BufferUtils.fromHex(buf);
    if (!buf || buf.byteLength === 0) {
      throw new Error("Invalid wallet seed");
    }
    const serialBuf = new SerialBuffer(buf);
    const keyPair = KeyPair.unserialize(serialBuf);
    return MultiSigWallet._loadMultiSig(keyPair, serialBuf);
  }
  static async loadEncrypted(buf, key) {
    if (typeof buf === "string")
      buf = BufferUtils.fromHex(buf);
    if (typeof key === "string")
      key = BufferUtils.fromUtf8(key);
    const serialBuf = new SerialBuffer(buf);
    const keyPair = await KeyPair.fromEncrypted(serialBuf, key);
    return MultiSigWallet._loadMultiSig(keyPair, serialBuf);
  }
  _minSignatures;
  _publicKeys;
  constructor(keyPair, minSignatures, publicKeys) {
    super(keyPair);
    this._minSignatures = minSignatures;
    this._publicKeys = publicKeys;
    this._publicKeys.sort((a, b) => a.compare(b));
    const merkleRoot = MerkleTree.computeRoot(this._publicKeys);
    this._address = Address.fromHash(merkleRoot);
  }
  exportPlain() {
    const buf = new SerialBuffer(this.exportedSize);
    this._keyPair.serialize(buf);
    buf.writeUint8(this._minSignatures);
    buf.writeUint8(this._publicKeys.length);
    for (const pubKey of this._publicKeys) {
      pubKey.serialize(buf);
    }
    return buf;
  }
  get exportedSize() {
    return this._keyPair.serializedSize + 1 + 1 + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);
  }
  async exportEncrypted(key) {
    if (typeof key === "string")
      key = BufferUtils.fromUtf8(key);
    const buf = new SerialBuffer(this.encryptedSize);
    buf.write(await this._keyPair.exportEncrypted(key));
    buf.writeUint8(this._minSignatures);
    buf.writeUint8(this._publicKeys.length);
    for (const pubKey of this._publicKeys) {
      pubKey.serialize(buf);
    }
    return buf;
  }
  get encryptedSize() {
    return this._keyPair.encryptedSize + 1 + 1 + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);
  }
  createTransaction(recipientAddr, value, fee, validityStartHeight) {
    return new ExtendedTransaction(
      this._address,
      Account.Type.BASIC,
      recipientAddr,
      Account.Type.BASIC,
      value,
      fee,
      validityStartHeight,
      Transaction.Flag.NONE,
      new Uint8Array(0)
    );
  }
  createCommitment() {
    return CommitmentPair.generate();
  }
  partiallySignTransaction(transaction, publicKeys, aggregatedCommitment, secret) {
    publicKeys = publicKeys.slice();
    publicKeys.sort((a, b) => a.compare(b));
    return PartialSignature.create(
      this._keyPair.privateKey,
      this._keyPair.publicKey,
      publicKeys,
      secret,
      aggregatedCommitment,
      transaction.serializeContent()
    );
  }
  signTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {
    if (signatures.length !== this._minSignatures) {
      throw new Error("Not enough signatures to complete this transaction");
    }
    const signature = Signature.fromPartialSignatures(aggregatedCommitment, signatures);
    return SignatureProof.multiSig(aggregatedPublicKey, this._publicKeys, signature);
  }
  completeTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {
    const proof = this.signTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures);
    transaction.proof = proof.serialize();
    return transaction;
  }
  get minSignatures() {
    return this._minSignatures;
  }
  get publicKeys() {
    return this._publicKeys;
  }
}

class BasicAccount extends Account {
  static copy(o) {
    if (!o)
      return o;
    return new BasicAccount(o._balance);
  }
  constructor(balance = 0) {
    super(Account.Type.BASIC, balance);
  }
  static unserialize(buf) {
    const type = buf.readUint8();
    if (type !== Account.Type.BASIC)
      throw new Error("Invalid account type");
    const balance = buf.readUint64();
    return new BasicAccount(balance);
  }
  static fromPlain(o) {
    if (!o)
      throw new Error("Invalid account");
    return new BasicAccount(o.balance);
  }
  equals(o) {
    return o instanceof BasicAccount && this._type === o._type && this._balance === o._balance;
  }
  toString() {
    return `BasicAccount{balance=${this._balance}}`;
  }
  static verifyOutgoingTransaction(transaction) {
    return SignatureProof.verifyTransaction(transaction);
  }
  static verifyIncomingTransaction(transaction) {
    if (transaction.data.byteLength > 64)
      return false;
    return true;
  }
  withBalance(balance) {
    return new BasicAccount(balance);
  }
  isInitial() {
    return this._balance === 0;
  }
  static dataToPlain(data) {
    return Account.dataToPlain(data);
  }
  static proofToPlain(proof) {
    try {
      const signatureProof = SignatureProof.unserialize(new SerialBuffer(proof));
      return {
        signature: signatureProof.signature?.toHex(),
        publicKey: signatureProof.publicKey.toHex(),
        signer: signatureProof.publicKey.toAddress().toPlain(),
        pathLength: signatureProof.merklePath.nodes.length
      };
    } catch (e) {
      return Account.proofToPlain(proof);
    }
  }
}
Account.INITIAL = new BasicAccount(0);
Account.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);

class Contract extends Account {
  constructor(type, balance) {
    super(type, balance);
  }
  static verifyIncomingTransaction(transaction) {
    if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {
      return false;
    }
    return true;
  }
  withIncomingTransaction(transaction, blockHeight, revert = false) {
    if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {
      throw new Error("Data error");
    }
    return super.withIncomingTransaction(transaction, blockHeight, revert);
  }
  withContractCommand(transaction, blockHeight, revert = false) {
    if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {
      return new BasicAccount(this.balance);
    }
    return this;
  }
}

class VestingContract extends Contract {
  _owner;
  _vestingStart;
  _vestingStepBlocks;
  _vestingStepAmount;
  _vestingTotalAmount;
  constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {
    super(Account.Type.VESTING, balance);
    if (!(owner instanceof Address))
      throw new Error("Malformed owner address");
    if (!NumberUtils.isUint32(vestingStart))
      throw new Error("Malformed vestingStart");
    if (!NumberUtils.isUint32(vestingStepBlocks))
      throw new Error("Malformed vestingStepBlocks");
    if (!NumberUtils.isUint64(vestingStepAmount))
      throw new Error("Malformed vestingStepAmount");
    if (!NumberUtils.isUint64(vestingTotalAmount))
      throw new Error("Malformed vestingTotalAmount");
    this._owner = owner;
    this._vestingStart = vestingStart;
    this._vestingStepBlocks = vestingStepBlocks;
    this._vestingStepAmount = vestingStepAmount;
    this._vestingTotalAmount = vestingTotalAmount;
  }
  static create(balance, blockHeight, transaction) {
    let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;
    const buf = new SerialBuffer(transaction.data);
    const owner = Address.unserialize(buf);
    vestingTotalAmount = transaction.value;
    switch (transaction.data.length) {
      case Address.SERIALIZED_SIZE + 4:
        vestingStart = 0;
        vestingStepBlocks = buf.readUint32();
        vestingStepAmount = vestingTotalAmount;
        break;
      case Address.SERIALIZED_SIZE + 16:
        vestingStart = buf.readUint32();
        vestingStepBlocks = buf.readUint32();
        vestingStepAmount = buf.readUint64();
        break;
      case Address.SERIALIZED_SIZE + 24:
        vestingStart = buf.readUint32();
        vestingStepBlocks = buf.readUint32();
        vestingStepAmount = buf.readUint64();
        vestingTotalAmount = buf.readUint64();
        break;
      default:
        throw new Error("Invalid transaction data");
    }
    return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);
  }
  static unserialize(buf) {
    const type = buf.readUint8();
    if (type !== Account.Type.VESTING)
      throw new Error("Invalid account type");
    const balance = buf.readUint64();
    const owner = Address.unserialize(buf);
    const vestingStart = buf.readUint32();
    const vestingStepBlocks = buf.readUint32();
    const vestingStepAmount = buf.readUint64();
    const vestingTotalAmount = buf.readUint64();
    return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);
  }
  static fromPlain(plain) {
    if (!plain)
      throw new Error("Invalid account");
    return new VestingContract(plain.balance, Address.fromAny(plain.owner), plain.vestingStart, plain.vestingStepBlocks, plain.vestingStepAmount, plain.vestingTotalAmount);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    super.serialize(buf);
    this._owner.serialize(buf);
    buf.writeUint32(this._vestingStart);
    buf.writeUint32(this._vestingStepBlocks);
    buf.writeUint64(this._vestingStepAmount);
    buf.writeUint64(this._vestingTotalAmount);
    return buf;
  }
  get serializedSize() {
    return super.serializedSize + this._owner.serializedSize + 4 + 4 + 8 + 8;
  }
  get owner() {
    return this._owner;
  }
  get vestingStart() {
    return this._vestingStart;
  }
  get vestingStepBlocks() {
    return this._vestingStepBlocks;
  }
  get vestingStepAmount() {
    return this._vestingStepAmount;
  }
  get vestingTotalAmount() {
    return this._vestingTotalAmount;
  }
  toString() {
    return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;
  }
  toPlain() {
    const plain = super.toPlain();
    plain.owner = this.owner.toPlain();
    plain.vestingStart = this.vestingStart;
    plain.vestingStepBlocks = this.vestingStepBlocks;
    plain.vestingStepAmount = this.vestingStepAmount;
    plain.vestingTotalAmount = this.vestingTotalAmount;
    return plain;
  }
  equals(o) {
    return o instanceof VestingContract && this._type === o._type && this._balance === o._balance && this._owner.equals(o._owner) && this._vestingStart === o._vestingStart && this._vestingStepBlocks === o._vestingStepBlocks && this._vestingStepAmount === o._vestingStepAmount && this._vestingTotalAmount === o._vestingTotalAmount;
  }
  static verifyOutgoingTransaction(transaction) {
    const buf = new SerialBuffer(transaction.proof);
    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {
      return false;
    }
    if (buf.readPos !== buf.byteLength) {
      return false;
    }
    return true;
  }
  static verifyIncomingTransaction(transaction) {
    switch (transaction.data.length) {
      case Address.SERIALIZED_SIZE + 4:
      case Address.SERIALIZED_SIZE + 16:
      case Address.SERIALIZED_SIZE + 24:
        return Contract.verifyIncomingTransaction(transaction);
      default:
        return false;
    }
  }
  withBalance(balance) {
    return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);
  }
  withIncomingTransaction(transaction, blockHeight, revert = false) {
    throw new Error("Illegal incoming transaction");
  }
  getMinCap(blockHeight) {
    return this._vestingStepBlocks && this._vestingStepAmount > 0 ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount) : 0;
  }
  static dataToPlain(data) {
    try {
      let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;
      const buf = new SerialBuffer(data);
      const owner = Address.unserialize(buf);
      switch (data.length) {
        case Address.SERIALIZED_SIZE + 4:
          vestingStart = 0;
          vestingStepBlocks = buf.readUint32();
          break;
        case Address.SERIALIZED_SIZE + 16:
          vestingStart = buf.readUint32();
          vestingStepBlocks = buf.readUint32();
          vestingStepAmount = buf.readUint64();
          break;
        case Address.SERIALIZED_SIZE + 24:
          vestingStart = buf.readUint32();
          vestingStepBlocks = buf.readUint32();
          vestingStepAmount = buf.readUint64();
          vestingTotalAmount = buf.readUint64();
          break;
        default:
          throw new Error("Invalid transaction data");
      }
      return {
        owner: owner.toPlain(),
        vestingStart,
        vestingStepBlocks,
        vestingStepAmount,
        vestingTotalAmount
      };
    } catch (e) {
      return Account.dataToPlain(data);
    }
  }
  static proofToPlain(proof) {
    try {
      const signatureProof = SignatureProof.unserialize(new SerialBuffer(proof));
      return {
        signature: signatureProof.signature?.toHex(),
        publicKey: signatureProof.publicKey.toHex(),
        signer: signatureProof.publicKey.toAddress().toPlain(),
        pathLength: signatureProof.merklePath.nodes.length
      };
    } catch (e) {
      return Account.proofToPlain(proof);
    }
  }
}
Account.TYPE_MAP.set(Account.Type.VESTING, VestingContract);

class HashedTimeLockedContract extends Contract {
  _sender;
  _recipient;
  _hashRoot;
  _hashCount;
  _timeout;
  _totalAmount;
  constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {
    super(Account.Type.HTLC, balance);
    if (!(sender instanceof Address))
      throw new Error("Malformed sender address");
    if (!(recipient instanceof Address))
      throw new Error("Malformed recipient address");
    if (!(hashRoot instanceof Hash))
      throw new Error("Malformed hashRoot");
    if (!NumberUtils.isUint8(hashCount) || hashCount === 0)
      throw new Error("Malformed hashCount");
    if (!NumberUtils.isUint32(timeout))
      throw new Error("Malformed timeout");
    if (!NumberUtils.isUint64(totalAmount))
      throw new Error("Malformed totalAmount");
    this._sender = sender;
    this._recipient = recipient;
    this._hashRoot = hashRoot;
    this._hashCount = hashCount;
    this._timeout = timeout;
    this._totalAmount = totalAmount;
  }
  static create(balance, blockHeight, transaction) {
    const buf = new SerialBuffer(transaction.data);
    const sender = Address.unserialize(buf);
    const recipient = Address.unserialize(buf);
    const hashAlgorithm = buf.readUint8();
    const hashRoot = Hash.unserialize(buf, hashAlgorithm);
    const hashCount = buf.readUint8();
    const timeout = buf.readUint32();
    return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);
  }
  static unserialize(buf) {
    const type = buf.readUint8();
    if (type !== Account.Type.HTLC)
      throw new Error("Invalid account type");
    const balance = buf.readUint64();
    const sender = Address.unserialize(buf);
    const recipient = Address.unserialize(buf);
    const hashAlgorithm = buf.readUint8();
    const hashRoot = Hash.unserialize(buf, hashAlgorithm);
    const hashCount = buf.readUint8();
    const timeout = buf.readUint32();
    const totalAmount = buf.readUint64();
    return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);
  }
  static fromPlain(plain) {
    if (!plain)
      throw new Error("Invalid account");
    return new HashedTimeLockedContract(plain.balance, Address.fromAny(plain.sender), Address.fromAny(plain.recipient), Hash.fromAny(plain.hashRoot, Hash.Algorithm.fromAny(plain.hashAlgorithm)), plain.hashCount, plain.timeout, plain.totalAmount);
  }
  serialize(buf) {
    buf = buf || new SerialBuffer(this.serializedSize);
    super.serialize(buf);
    this._sender.serialize(buf);
    this._recipient.serialize(buf);
    buf.writeUint8(this._hashRoot.algorithm);
    this._hashRoot.serialize(buf);
    buf.writeUint8(this._hashCount);
    buf.writeUint32(this._timeout);
    buf.writeUint64(this._totalAmount);
    return buf;
  }
  get serializedSize() {
    return super.serializedSize + this._sender.serializedSize + this._recipient.serializedSize + 1 + this._hashRoot.serializedSize + 1 + 4 + 8;
  }
  get sender() {
    return this._sender;
  }
  get recipient() {
    return this._recipient;
  }
  get hashAlgorithm() {
    return this._hashRoot.algorithm;
  }
  get hashRoot() {
    return this._hashRoot;
  }
  get hashCount() {
    return this._hashCount;
  }
  get timeout() {
    return this._timeout;
  }
  get totalAmount() {
    return this._totalAmount;
  }
  toString() {
    return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;
  }
  toPlain() {
    const plain = super.toPlain();
    plain.sender = this.sender.toPlain();
    plain.recipient = this.recipient.toPlain();
    plain.hashAlgorithm = Hash.Algorithm.toString(this.hashRoot.algorithm);
    plain.hashRoot = this.hashRoot.toPlain();
    plain.hashCount = this.hashCount;
    plain.timeout = this.timeout;
    plain.totalAmount = this.totalAmount;
    return plain;
  }
  equals(o) {
    return o instanceof HashedTimeLockedContract && this._type === o._type && this._balance === o._balance && this._sender.equals(o._sender) && this._recipient.equals(o._recipient) && this._hashRoot.equals(o._hashRoot) && this._hashCount === o._hashCount && this._timeout === o._timeout && this._totalAmount === o._totalAmount;
  }
  static verifyOutgoingTransaction(transaction) {
    try {
      const buf = new SerialBuffer(transaction.proof);
      const type = buf.readUint8();
      switch (type) {
        case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {
          const hashAlgorithm = buf.readUint8();
          const hashDepth = buf.readUint8();
          const hashRoot = Hash.unserialize(buf, hashAlgorithm);
          let preImage = Hash.unserialize(buf, hashAlgorithm);
          for (let i = 0; i < hashDepth; ++i) {
            preImage = Hash.compute(preImage.array, hashAlgorithm);
          }
          if (!hashRoot.equals(preImage)) {
            return false;
          }
          if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {
            return false;
          }
          break;
        }
        case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {
          if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {
            return false;
          }
          if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {
            return false;
          }
          break;
        }
        case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:
          if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {
            return false;
          }
          break;
        default:
          return false;
      }
      if (buf.readPos !== buf.byteLength) {
        return false;
      }
      return true;
    } catch (e) {
      return false;
    }
  }
  static verifyIncomingTransaction(transaction) {
    try {
      const buf = new SerialBuffer(transaction.data);
      Address.unserialize(buf);
      Address.unserialize(buf);
      const hashAlgorithm = buf.readUint8();
      Hash.unserialize(buf, hashAlgorithm);
      const hashCount = buf.readUint8();
      buf.readUint32();
      if (hashCount === 0) {
        return false;
      }
      if (hashAlgorithm === Hash.Algorithm.ARGON2D) {
        return false;
      }
      if (buf.readPos !== buf.byteLength) {
        return false;
      }
      return Contract.verifyIncomingTransaction(transaction);
    } catch (e) {
      return false;
    }
  }
  withBalance(balance) {
    return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);
  }
  withIncomingTransaction(transaction, blockHeight, revert = false) {
    throw new Error("Illegal incoming transaction");
  }
  static dataToPlain(data) {
    try {
      const buf = new SerialBuffer(data);
      const sender = Address.unserialize(buf);
      const recipient = Address.unserialize(buf);
      const hashAlgorithm = buf.readUint8();
      const hashRoot = Hash.unserialize(buf, hashAlgorithm);
      const hashCount = buf.readUint8();
      const timeout = buf.readUint32();
      return {
        sender: sender.toPlain(),
        recipient: recipient.toPlain(),
        hashAlgorithm: Hash.Algorithm.toString(hashAlgorithm),
        hashRoot: hashRoot.toPlain(),
        hashCount,
        timeout
      };
    } catch (e) {
      return Account.dataToPlain(data);
    }
  }
  static proofToPlain(proof) {
    try {
      const buf = new SerialBuffer(proof);
      const type = buf.readUint8();
      switch (type) {
        case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {
          const hashAlgorithm = buf.readUint8();
          const hashDepth = buf.readUint8();
          const hashRoot = Hash.unserialize(buf, hashAlgorithm);
          const preImage = Hash.unserialize(buf, hashAlgorithm);
          const signatureProof = SignatureProof.unserialize(buf);
          return {
            type: HashedTimeLockedContract.ProofType.toString(type),
            hashAlgorithm: Hash.Algorithm.toString(hashAlgorithm),
            hashDepth,
            hashRoot: hashRoot.toPlain(),
            preImage: preImage.toPlain(),
            signer: signatureProof.publicKey.toAddress().toPlain(),
            signature: signatureProof.signature?.toHex(),
            publicKey: signatureProof.publicKey.toHex(),
            pathLength: signatureProof.merklePath.nodes.length
          };
        }
        case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {
          const signatureProof = SignatureProof.unserialize(buf);
          const creatorSignatureProof = SignatureProof.unserialize(buf);
          return {
            type: HashedTimeLockedContract.ProofType.toString(type),
            signer: signatureProof.publicKey.toAddress().toPlain(),
            signature: signatureProof.signature?.toHex(),
            publicKey: signatureProof.publicKey.toHex(),
            pathLength: signatureProof.merklePath.nodes.length,
            creator: creatorSignatureProof.publicKey.toAddress().toPlain(),
            creatorSignature: creatorSignatureProof.signature?.toHex(),
            creatorPublicKey: creatorSignatureProof.publicKey.toHex(),
            creatorPathLength: creatorSignatureProof.merklePath.nodes.length
          };
        }
        case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {
          const creatorSignatureProof = SignatureProof.unserialize(buf);
          return {
            type: HashedTimeLockedContract.ProofType.toString(type),
            creator: creatorSignatureProof.publicKey.toAddress().toPlain(),
            creatorSignature: creatorSignatureProof.signature?.toHex(),
            creatorPublicKey: creatorSignatureProof.publicKey.toHex(),
            creatorPathLength: creatorSignatureProof.merklePath.nodes.length
          };
        }
        default:
          throw new Error("Invalid proof type");
      }
    } catch (e) {
      return Account.proofToPlain(proof);
    }
  }
}
((HashedTimeLockedContract2) => {
  ((ProofType2) => {
    ProofType2[ProofType2["REGULAR_TRANSFER"] = 1] = "REGULAR_TRANSFER";
    ProofType2[ProofType2["EARLY_RESOLVE"] = 2] = "EARLY_RESOLVE";
    ProofType2[ProofType2["TIMEOUT_RESOLVE"] = 3] = "TIMEOUT_RESOLVE";
  })(HashedTimeLockedContract2.ProofType || (HashedTimeLockedContract2.ProofType = {}));
  ((ProofType2) => {
    function toString(proofType) {
      switch (proofType) {
        case 1 /* REGULAR_TRANSFER */:
          return "regular-transfer";
        case 2 /* EARLY_RESOLVE */:
          return "early-resolve";
        case 3 /* TIMEOUT_RESOLVE */:
          return "timeout-resolve";
        default:
          throw new Error("Invalid proof type");
      }
    }
    ProofType2.toString = toString;
  })(HashedTimeLockedContract2.ProofType || (HashedTimeLockedContract2.ProofType = {}));
})(HashedTimeLockedContract || (HashedTimeLockedContract = {}));
Account.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);

setWasmInit(() => nimiqWasm());
async function initialize(options) {
  if (options?.wasm)
    console.warn("Calling initialize() with options.wasm is not necessary for the standard version of this library, as the WASM is already included.");
  return WasmHelper.doImport();
}

function init(Module) {
  Module = Module || {};
  var Module = Module;
  var Module;
  if (!Module)
    Module = eval("(function() { try { return Module || {} } catch(e) { return {} } })()");
  var moduleOverrides = {};
  for (var key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var ENVIRONMENT_IS_WEB = false;
  var ENVIRONMENT_IS_WORKER = false;
  var ENVIRONMENT_IS_NODE = false;
  var ENVIRONMENT_IS_SHELL = false;
  if (Module["ENVIRONMENT"]) {
    if (Module["ENVIRONMENT"] === "WEB") {
      ENVIRONMENT_IS_WEB = true;
    } else if (Module["ENVIRONMENT"] === "WORKER") {
      ENVIRONMENT_IS_WORKER = true;
    } else if (Module["ENVIRONMENT"] === "NODE") {
      ENVIRONMENT_IS_NODE = true;
    } else if (Module["ENVIRONMENT"] === "SHELL") {
      ENVIRONMENT_IS_SHELL = true;
    } else {
      throw new Error("The provided Module['ENVIRONMENT'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.");
    }
  } else {
    ENVIRONMENT_IS_WEB = typeof window === "object";
    ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
    ENVIRONMENT_IS_NODE = typeof process === "object" && typeof require === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
  }
  if (ENVIRONMENT_IS_NODE) {
    if (!Module["print"])
      Module["print"] = console.log;
    if (!Module["printErr"])
      Module["printErr"] = console.warn;
    var nodeFS;
    var nodePath;
    Module["read"] = function read2(filename, binary) {
      if (!nodeFS)
        nodeFS = require("fs");
      if (!nodePath)
        nodePath = require("path");
      filename = nodePath["normalize"](filename);
      var ret = nodeFS["readFileSync"](filename);
      return binary ? ret : ret.toString();
    };
    Module["readBinary"] = function readBinary(filename) {
      var ret = Module["read"](filename, true);
      if (!ret.buffer) {
        ret = new Uint8Array(ret);
      }
      assert(ret.buffer);
      return ret;
    };
    Module["load"] = function load(f) {
      globalEval(read(f));
    };
    if (!Module["thisProgram"]) {
      if (process["argv"].length > 1) {
        Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/");
      } else {
        Module["thisProgram"] = "unknown-program";
      }
    }
    Module["arguments"] = process["argv"].slice(2);
    if (typeof module !== "undefined") {
      module["exports"] = Module;
    }
    process["on"]("uncaughtException", function(ex) {
      if (!(ex instanceof ExitStatus)) {
        throw ex;
      }
    });
    Module["inspect"] = function() {
      return "[Emscripten Module object]";
    };
  } else if (ENVIRONMENT_IS_SHELL) {
    if (!Module["print"])
      Module["print"] = print;
    if (typeof printErr != "undefined")
      Module["printErr"] = printErr;
    if (typeof read != "undefined") {
      Module["read"] = read;
    } else {
      Module["read"] = function read2() {
        throw "no read() available";
      };
    }
    Module["readBinary"] = function readBinary(f) {
      if (typeof readbuffer === "function") {
        return new Uint8Array(readbuffer(f));
      }
      var data2 = read(f, "binary");
      assert(typeof data2 === "object");
      return data2;
    };
    if (typeof scriptArgs != "undefined") {
      Module["arguments"] = scriptArgs;
    } else if (typeof arguments != "undefined") {
      Module["arguments"] = arguments;
    }
    if (typeof quit === "function") {
      Module["quit"] = function(status, toThrow) {
        quit(status);
      };
    }
    eval("if (typeof gc === 'function' && gc.toString().indexOf('[native code]') > 0) var gc = undefined");
  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
    Module["read"] = function read2(url) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, false);
      xhr.send(null);
      return xhr.responseText;
    };
    if (ENVIRONMENT_IS_WORKER) {
      Module["readBinary"] = function read2(url) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);
        xhr.responseType = "arraybuffer";
        xhr.send(null);
        return xhr.response;
      };
    }
    Module["readAsync"] = function readAsync(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response);
        } else {
          onerror();
        }
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };
    if (typeof arguments != "undefined") {
      Module["arguments"] = arguments;
    }
    if (typeof console !== "undefined") {
      if (!Module["print"])
        Module["print"] = function print2(x) {
          console.log(x);
        };
      if (!Module["printErr"])
        Module["printErr"] = function printErr2(x) {
          console.warn(x);
        };
    } else {
      var TRY_USE_DUMP = false;
      if (!Module["print"])
        Module["print"] = TRY_USE_DUMP && typeof dump !== "undefined" ? function(x) {
          dump(x);
        } : function(x) {
        };
    }
    if (ENVIRONMENT_IS_WORKER) {
      Module["load"] = importScripts;
    }
    if (typeof Module["setWindowTitle"] === "undefined") {
      Module["setWindowTitle"] = function(title) {
        document.title = title;
      };
    }
  } else {
    throw "Unknown runtime environment. Where are we?";
  }
  function globalEval(x) {
    eval.call(null, x);
  }
  if (!Module["load"] && Module["read"]) {
    Module["load"] = function load(f) {
      globalEval(Module["read"](f));
    };
  }
  if (!Module["print"]) {
    Module["print"] = function() {
    };
  }
  if (!Module["printErr"]) {
    Module["printErr"] = Module["print"];
  }
  if (!Module["arguments"]) {
    Module["arguments"] = [];
  }
  if (!Module["thisProgram"]) {
    Module["thisProgram"] = "./this.program";
  }
  if (!Module["quit"]) {
    Module["quit"] = function(status, toThrow) {
      throw toThrow;
    };
  }
  Module.print = Module["print"];
  Module.printErr = Module["printErr"];
  Module["preRun"] = [];
  Module["postRun"] = [];
  for (var key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = void 0;
  var Runtime = {
    setTempRet0: function(value) {
      tempRet0 = value;
      return value;
    },
    getTempRet0: function() {
      return tempRet0;
    },
    stackSave: function() {
      return STACKTOP;
    },
    stackRestore: function(stackTop) {
      STACKTOP = stackTop;
    },
    getNativeTypeSize: function(type2) {
      switch (type2) {
        case "i1":
        case "i8":
          return 1;
        case "i16":
          return 2;
        case "i32":
          return 4;
        case "i64":
          return 8;
        case "float":
          return 4;
        case "double":
          return 8;
        default: {
          if (type2[type2.length - 1] === "*") {
            return Runtime.QUANTUM_SIZE;
          } else if (type2[0] === "i") {
            var bits = parseInt(type2.substr(1));
            assert(bits % 8 === 0);
            return bits / 8;
          } else {
            return 0;
          }
        }
      }
    },
    getNativeFieldSize: function(type2) {
      return Math.max(Runtime.getNativeTypeSize(type2), Runtime.QUANTUM_SIZE);
    },
    STACK_ALIGN: 16,
    prepVararg: function(ptr, type2) {
      if (type2 === "double" || type2 === "i64") {
        if (ptr & 7) {
          assert((ptr & 7) === 4);
          ptr += 4;
        }
      } else {
        assert((ptr & 3) === 0);
      }
      return ptr;
    },
    getAlignSize: function(type2, size, vararg) {
      if (!vararg && (type2 == "i64" || type2 == "double"))
        return 8;
      if (!type2)
        return Math.min(size, 8);
      return Math.min(size || (type2 ? Runtime.getNativeFieldSize(type2) : 0), Runtime.QUANTUM_SIZE);
    },
    dynCall: function(sig, ptr, args) {
      if (args && args.length) {
        return Module["dynCall_" + sig].apply(null, [ptr].concat(args));
      } else {
        return Module["dynCall_" + sig].call(null, ptr);
      }
    },
    functionPointers: [],
    addFunction: function(func2) {
      for (var i2 = 0; i2 < Runtime.functionPointers.length; i2++) {
        if (!Runtime.functionPointers[i2]) {
          Runtime.functionPointers[i2] = func2;
          return 2 * (1 + i2);
        }
      }
      throw "Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";
    },
    removeFunction: function(index) {
      Runtime.functionPointers[(index - 2) / 2] = null;
    },
    warnOnce: function(text) {
      if (!Runtime.warnOnce.shown)
        Runtime.warnOnce.shown = {};
      if (!Runtime.warnOnce.shown[text]) {
        Runtime.warnOnce.shown[text] = 1;
        Module.printErr(text);
      }
    },
    funcWrappers: {},
    getFuncWrapper: function(func2, sig) {
      assert(sig);
      if (!Runtime.funcWrappers[sig]) {
        Runtime.funcWrappers[sig] = {};
      }
      var sigCache = Runtime.funcWrappers[sig];
      if (!sigCache[func2]) {
        if (sig.length === 1) {
          sigCache[func2] = function dynCall_wrapper() {
            return Runtime.dynCall(sig, func2);
          };
        } else if (sig.length === 2) {
          sigCache[func2] = function dynCall_wrapper(arg2) {
            return Runtime.dynCall(sig, func2, [arg2]);
          };
        } else {
          sigCache[func2] = function dynCall_wrapper() {
            return Runtime.dynCall(sig, func2, Array.prototype.slice.call(arguments));
          };
        }
      }
      return sigCache[func2];
    },
    getCompilerSetting: function(name) {
      throw "You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";
    },
    stackAlloc: function(size) {
      var ret = STACKTOP;
      STACKTOP = STACKTOP + size | 0;
      STACKTOP = STACKTOP + 15 & -16;
      return ret;
    },
    staticAlloc: function(size) {
      var ret = STATICTOP;
      STATICTOP = STATICTOP + size | 0;
      STATICTOP = STATICTOP + 15 & -16;
      return ret;
    },
    dynamicAlloc: function(size) {
      var ret = HEAP32[DYNAMICTOP_PTR >> 2];
      var end = (ret + size + 15 | 0) & -16;
      HEAP32[DYNAMICTOP_PTR >> 2] = end;
      if (end >= TOTAL_MEMORY) {
        var success = enlargeMemory();
        if (!success) {
          HEAP32[DYNAMICTOP_PTR >> 2] = ret;
          return 0;
        }
      }
      return ret;
    },
    alignMemory: function(size, quantum) {
      var ret = size = Math.ceil(size / (quantum ? quantum : 16)) * (quantum ? quantum : 16);
      return ret;
    },
    makeBigInt: function(low, high, unsigned) {
      var ret = unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296 : +(low >>> 0) + +(high | 0) * 4294967296;
      return ret;
    },
    GLOBAL_BASE: 1024,
    QUANTUM_SIZE: 4,
    __dummy__: 0
  };
  Runtime["addFunction"] = Runtime.addFunction;
  Runtime["removeFunction"] = Runtime.removeFunction;
  var ABORT = 0;
  function assert(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function setValue(ptr, value, type2, noSafe) {
    type2 = type2 || "i8";
    if (type2.charAt(type2.length - 1) === "*")
      type2 = "i32";
    switch (type2) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type2);
    }
  }
  function getValue(ptr, type2, noSafe) {
    type2 = type2 || "i8";
    if (type2.charAt(type2.length - 1) === "*")
      type2 = "i32";
    switch (type2) {
      case "i1":
        return HEAP8[ptr >> 0];
      case "i8":
        return HEAP8[ptr >> 0];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP32[ptr >> 2];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      default:
        abort("invalid type for setValue: " + type2);
    }
    return null;
  }
  var ALLOC_NORMAL = 0;
  var ALLOC_STATIC = 2;
  var ALLOC_NONE = 4;
  function allocate(slab, types, allocator, ptr) {
    var zeroinit, size;
    if (typeof slab === "number") {
      zeroinit = true;
      size = slab;
    } else {
      zeroinit = false;
      size = slab.length;
    }
    var singleType = typeof types === "string" ? types : null;
    var ret;
    if (allocator == ALLOC_NONE) {
      ret = ptr;
    } else {
      ret = [typeof _malloc === "function" ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === void 0 ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
    }
    if (zeroinit) {
      var ptr = ret, stop;
      assert((ret & 3) == 0);
      stop = ret + (size & ~3);
      for (; ptr < stop; ptr += 4) {
        HEAP32[ptr >> 2] = 0;
      }
      stop = ret + size;
      while (ptr < stop) {
        HEAP8[ptr++ >> 0] = 0;
      }
      return ret;
    }
    if (singleType === "i8") {
      if (slab.subarray || slab.slice) {
        HEAPU8.set(slab, ret);
      } else {
        HEAPU8.set(new Uint8Array(slab), ret);
      }
      return ret;
    }
    var i2 = 0, type2, typeSize, previousType;
    while (i2 < size) {
      var curr = slab[i2];
      if (typeof curr === "function") {
        curr = Runtime.getFunctionIndex(curr);
      }
      type2 = singleType || types[i2];
      if (type2 === 0) {
        i2++;
        continue;
      }
      if (type2 == "i64")
        type2 = "i32";
      setValue(ret + i2, curr, type2);
      if (previousType !== type2) {
        typeSize = Runtime.getNativeTypeSize(type2);
        previousType = type2;
      }
      i2 += typeSize;
    }
    return ret;
  }
  function Pointer_stringify(ptr, length) {
    if (length === 0 || !ptr)
      return "";
    var hasUtf = 0;
    var t;
    var i2 = 0;
    while (1) {
      t = HEAPU8[ptr + i2 >> 0];
      hasUtf |= t;
      if (t == 0 && !length)
        break;
      i2++;
      if (length && i2 == length)
        break;
    }
    if (!length)
      length = i2;
    var ret = "";
    if (hasUtf < 128) {
      var MAX_CHUNK = 1024;
      var curr;
      while (length > 0) {
        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
        ret = ret ? ret + curr : curr;
        ptr += MAX_CHUNK;
        length -= MAX_CHUNK;
      }
      return ret;
    }
    return Module["UTF8ToString"](ptr);
  }
  typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0))
      return 0;
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var u = str.charCodeAt(i2);
      if (u >= 55296 && u <= 57343)
        u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i2) & 1023;
      if (u <= 127) {
        if (outIdx >= endIdx)
          break;
        outU8Array[outIdx++] = u;
      } else if (u <= 2047) {
        if (outIdx + 1 >= endIdx)
          break;
        outU8Array[outIdx++] = 192 | u >> 6;
        outU8Array[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
        if (outIdx + 2 >= endIdx)
          break;
        outU8Array[outIdx++] = 224 | u >> 12;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      } else if (u <= 2097151) {
        if (outIdx + 3 >= endIdx)
          break;
        outU8Array[outIdx++] = 240 | u >> 18;
        outU8Array[outIdx++] = 128 | u >> 12 & 63;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      } else if (u <= 67108863) {
        if (outIdx + 4 >= endIdx)
          break;
        outU8Array[outIdx++] = 248 | u >> 24;
        outU8Array[outIdx++] = 128 | u >> 18 & 63;
        outU8Array[outIdx++] = 128 | u >> 12 & 63;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      } else {
        if (outIdx + 5 >= endIdx)
          break;
        outU8Array[outIdx++] = 252 | u >> 30;
        outU8Array[outIdx++] = 128 | u >> 24 & 63;
        outU8Array[outIdx++] = 128 | u >> 18 & 63;
        outU8Array[outIdx++] = 128 | u >> 12 & 63;
        outU8Array[outIdx++] = 128 | u >> 6 & 63;
        outU8Array[outIdx++] = 128 | u & 63;
      }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }
  function lengthBytesUTF8(str) {
    var len = 0;
    for (var i2 = 0; i2 < str.length; ++i2) {
      var u = str.charCodeAt(i2);
      if (u >= 55296 && u <= 57343)
        u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i2) & 1023;
      if (u <= 127) {
        ++len;
      } else if (u <= 2047) {
        len += 2;
      } else if (u <= 65535) {
        len += 3;
      } else if (u <= 2097151) {
        len += 4;
      } else if (u <= 67108863) {
        len += 5;
      } else {
        len += 6;
      }
    }
    return len;
  }
  typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function demangle(func2) {
    var __cxa_demangle_func = Module["___cxa_demangle"] || Module["__cxa_demangle"];
    if (__cxa_demangle_func) {
      try {
        var s = func2.substr(1);
        var len = lengthBytesUTF8(s) + 1;
        var buf = _malloc(len);
        stringToUTF8(s, buf, len);
        var status = _malloc(4);
        var ret = __cxa_demangle_func(buf, 0, 0, status);
        if (getValue(status, "i32") === 0 && ret) {
          return Pointer_stringify(ret);
        }
      } catch (e) {
      } finally {
        if (buf)
          _free(buf);
        if (status)
          _free(status);
        if (ret)
          _free(ret);
      }
      return func2;
    }
    Runtime.warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");
    return func2;
  }
  function demangleAll(text) {
    var regex = /__Z[\w\d_]+/g;
    return text.replace(regex, function(x) {
      var y = demangle(x);
      return x === y ? x : x + " [" + y + "]";
    });
  }
  function jsStackTrace() {
    var err = new Error();
    if (!err.stack) {
      try {
        throw new Error(0);
      } catch (e) {
        err = e;
      }
      if (!err.stack) {
        return "(no stack trace available)";
      }
    }
    return err.stack.toString();
  }
  function stackTrace() {
    var js = jsStackTrace();
    if (Module["extraStackTrace"])
      js += "\n" + Module["extraStackTrace"]();
    return demangleAll(js);
  }
  var WASM_PAGE_SIZE = 65536;
  var ASMJS_PAGE_SIZE = 16777216;
  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple;
    }
    return x;
  }
  var HEAP;
  var buffer;
  var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBuffer(buf) {
    Module["buffer"] = buffer = buf;
  }
  function updateGlobalBufferViews() {
    Module["HEAP8"] = HEAP8 = new Int8Array(buffer);
    Module["HEAP16"] = HEAP16 = new Int16Array(buffer);
    Module["HEAP32"] = HEAP32 = new Int32Array(buffer);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer);
  }
  var STATIC_BASE, STATICTOP;
  var STACK_BASE, STACKTOP, STACK_MAX;
  var DYNAMIC_BASE, DYNAMICTOP_PTR;
  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;
  function abortOnCannotGrowMemory() {
    abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
  }
  function enlargeMemory() {
    abortOnCannotGrowMemory();
  }
  var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;
  var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216;
  if (TOTAL_MEMORY < TOTAL_STACK)
    Module.printErr("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");
  if (Module["buffer"]) {
    buffer = Module["buffer"];
  } else {
    if (typeof WebAssembly === "object" && typeof WebAssembly.Memory === "function") {
      Module["wasmMemory"] = new WebAssembly.Memory({
        initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
        maximum: TOTAL_MEMORY / WASM_PAGE_SIZE
      });
      buffer = Module["wasmMemory"].buffer;
    } else {
      buffer = new ArrayBuffer(TOTAL_MEMORY);
    }
  }
  updateGlobalBufferViews();
  function getTotalMemory() {
    return TOTAL_MEMORY;
  }
  HEAP32[0] = 1668509029;
  HEAP16[1] = 25459;
  if (HEAPU8[2] !== 115 || HEAPU8[3] !== 99)
    throw "Runtime error: expected the system to be little-endian!";
  Module["HEAP"] = HEAP;
  Module["buffer"] = buffer;
  Module["HEAP8"] = HEAP8;
  Module["HEAP16"] = HEAP16;
  Module["HEAP32"] = HEAP32;
  Module["HEAPU8"] = HEAPU8;
  Module["HEAPU16"] = HEAPU16;
  Module["HEAPU32"] = HEAPU32;
  Module["HEAPF32"] = HEAPF32;
  Module["HEAPF64"] = HEAPF64;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback();
        continue;
      }
      var func2 = callback.func;
      if (typeof func2 === "number") {
        if (callback.arg === void 0) {
          Module["dynCall_v"](func2);
        } else {
          Module["dynCall_vi"](func2, callback.arg);
        }
      } else {
        func2(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATEXIT__ = [];
  var __ATPOSTRUN__ = [];
  var runtimeInitialized = false;
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function ensureInitRuntime() {
    if (runtimeInitialized)
      return;
    runtimeInitialized = true;
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function exitRuntime() {
    callRuntimeCallbacks(__ATEXIT__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull)
      u8array.length = numBytesWritten;
    return u8array;
  }
  if (!Math["imul"] || Math["imul"](4294967295, 5) !== -5)
    Math["imul"] = function imul(a, b) {
      var ah = a >>> 16;
      var al = a & 65535;
      var bh = b >>> 16;
      var bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16) | 0;
    };
  Math.imul = Math["imul"];
  if (!Math["fround"]) {
    var froundBuffer = new Float32Array(1);
    Math["fround"] = function(x) {
      froundBuffer[0] = x;
      return froundBuffer[0];
    };
  }
  Math.fround = Math["fround"];
  if (!Math["clz32"])
    Math["clz32"] = function(x) {
      x = x >>> 0;
      for (var i2 = 0; i2 < 32; i2++) {
        if (x & 1 << 31 - i2)
          return i2;
      }
      return 32;
    };
  Math.clz32 = Math["clz32"];
  if (!Math["trunc"])
    Math["trunc"] = function(x) {
      return x < 0 ? Math.ceil(x) : Math.floor(x);
    };
  Math.trunc = Math["trunc"];
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  var memoryInitializer = null;
  function integrateWasmJS(Module) {
    var method = Module["wasmJSMethod"] || "native-wasm";
    Module["wasmJSMethod"] = method;
    var wasmTextFile = Module["wasmTextFile"] || "worker-wasm.wast";
    var wasmBinaryFile = Module["wasmBinaryFile"] || "worker-wasm.wasm";
    var asmjsCodeFile = Module["asmjsCodeFile"] || "worker-wasm.temp.asm.js";
    var wasmPageSize = 64 * 1024;
    var asm2wasmImports = {
      "f64-rem": function(x, y) {
        return x % y;
      },
      "f64-to-int": function(x) {
        return x | 0;
      },
      "i32s-div": function(x, y) {
        return (x | 0) / (y | 0) | 0;
      },
      "i32u-div": function(x, y) {
        return (x >>> 0) / (y >>> 0) >>> 0;
      },
      "i32s-rem": function(x, y) {
        return (x | 0) % (y | 0) | 0;
      },
      "i32u-rem": function(x, y) {
        return (x >>> 0) % (y >>> 0) >>> 0;
      },
      debugger: function() {
        debugger;
      }
    };
    var info = {
      global: null,
      env: null,
      asm2wasm: asm2wasmImports,
      parent: Module
    };
    var exports = null;
    function lookupImport(mod, base) {
      var lookup = info;
      if (mod.indexOf(".") < 0) {
        lookup = (lookup || {})[mod];
      } else {
        var parts = mod.split(".");
        lookup = (lookup || {})[parts[0]];
        lookup = (lookup || {})[parts[1]];
      }
      if (base) {
        lookup = (lookup || {})[base];
      }
      if (lookup === void 0) {
        abort("bad lookupImport to (" + mod + ")." + base);
      }
      return lookup;
    }
    function mergeMemory(newBuffer) {
      var oldBuffer = Module["buffer"];
      if (newBuffer.byteLength < oldBuffer.byteLength) {
        Module["printErr"]("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");
      }
      var oldView = new Int8Array(oldBuffer);
      var newView = new Int8Array(newBuffer);
      if (!memoryInitializer) {
        oldView.set(newView.subarray(Module["STATIC_BASE"], Module["STATIC_BASE"] + Module["STATIC_BUMP"]), Module["STATIC_BASE"]);
      }
      newView.set(oldView);
      updateGlobalBuffer(newBuffer);
      updateGlobalBufferViews();
    }
    function fixImports(imports) {
      return imports;
    }
    function getBinaryModule() {
      if (Module["wasmModule"]) {
        return Module["wasmModule"];
      }
      var binary;
      if (Module["wasmBinary"]) {
        binary = Module["wasmBinary"];
        binary = new Uint8Array(binary);
      } else if (Module["readBinary"]) {
        binary = Module["readBinary"](wasmBinaryFile);
      } else {
        throw "on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)";
      }
      return WebAssembly.compile(binary);
    }
    function getBinaryModulePromise() {
      if (!Module["wasmModule"] && !Module["wasmBinary"] && typeof fetch === "function") {
        return fetch(wasmBinaryFile).then(function(response) {
          return response.arrayBuffer().then(function(buf) {
            return WebAssembly.compile(buf);
          });
        });
      }
      return new Promise(function(resolve, reject) {
        resolve(getBinaryModule());
      });
    }
    function doJustAsm(global, env, providedBuffer) {
      if (typeof Module["asm"] !== "function" || Module["asm"] === methodHandler) {
        if (!Module["asmPreload"]) {
          eval(Module["read"](asmjsCodeFile));
        } else {
          Module["asm"] = Module["asmPreload"];
        }
      }
      if (typeof Module["asm"] !== "function") {
        Module["printErr"]("asm evalling did not set the module properly");
        return false;
      }
      return Module["asm"](global, env, providedBuffer);
    }
    function doNativeWasm(global2, env2, providedBuffer2) {
      if (typeof WebAssembly !== "object") {
        Module["printErr"]("no native wasm support detected");
        return false;
      }
      if (!(Module["wasmMemory"] instanceof WebAssembly.Memory)) {
        Module["printErr"]("no native wasm Memory in use");
        return false;
      }
      env2["memory"] = Module["wasmMemory"];
      info["global"] = {
        NaN: NaN,
        Infinity: Infinity
      };
      info["global.Math"] = global2.Math;
      info["env"] = env2;
      function receiveInstance(instance) {
        exports = instance.exports;
        if (exports.memory)
          mergeMemory(exports.memory);
        Module["asm"] = exports;
        Module["usingWasm"] = true;
        removeRunDependency();
      }
      addRunDependency();
      if (Module["instantiateWasm"]) {
        try {
          return Module["instantiateWasm"](info, receiveInstance);
        } catch (e) {
          Module["printErr"]("Module.instantiateWasm callback failed with error: " + e);
          return false;
        }
      }
      Module["printErr"]("asynchronously preparing wasm");
      getBinaryModulePromise().then(function(mod) {
        return WebAssembly.instantiate(mod, info);
      }).then(function(instance) {
        receiveInstance(instance);
      }).catch(function(reason) {
        Module["printErr"]("failed to asynchronously prepare wasm: " + reason);
        Module["quit"](1, reason);
      });
      return {};
    }
    function doWasmPolyfill(global2, env2, providedBuffer2, method2) {
      if (typeof WasmJS !== "function") {
        Module["printErr"]("WasmJS not detected - polyfill not bundled?");
        return false;
      }
      var wasmJS = WasmJS({});
      wasmJS["outside"] = Module;
      wasmJS["info"] = info;
      wasmJS["lookupImport"] = lookupImport;
      assert(providedBuffer2 === Module["buffer"]);
      info.global = global2;
      info.env = env2;
      assert(providedBuffer2 === Module["buffer"]);
      env2["memory"] = providedBuffer2;
      assert(env2["memory"] instanceof ArrayBuffer);
      wasmJS["providedTotalMemory"] = Module["buffer"].byteLength;
      var code;
      if (method2 === "interpret-binary") {
        code = getBinary();
      } else {
        code = Module["read"](method2 == "interpret-asm2wasm" ? asmjsCodeFile : wasmTextFile);
      }
      var temp;
      if (method2 == "interpret-asm2wasm") {
        temp = wasmJS["_malloc"](code.length + 1);
        wasmJS["writeAsciiToMemory"](code, temp);
        wasmJS["_load_asm2wasm"](temp);
      } else if (method2 === "interpret-s-expr") {
        temp = wasmJS["_malloc"](code.length + 1);
        wasmJS["writeAsciiToMemory"](code, temp);
        wasmJS["_load_s_expr2wasm"](temp);
      } else if (method2 === "interpret-binary") {
        temp = wasmJS["_malloc"](code.length);
        wasmJS["HEAPU8"].set(code, temp);
        wasmJS["_load_binary2wasm"](temp, code.length);
      } else {
        throw "what? " + method2;
      }
      wasmJS["_free"](temp);
      wasmJS["_instantiate"](temp);
      if (Module["newBuffer"]) {
        mergeMemory(Module["newBuffer"]);
        Module["newBuffer"] = null;
      }
      exports = wasmJS["asmExports"];
      return exports;
    }
    Module["asmPreload"] = Module["asm"];
    Module["reallocBuffer"] = function(size) {
      var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;
      size = alignUp(size, PAGE_MULTIPLE);
      var old = Module["buffer"];
      var oldSize = old.byteLength;
      if (Module["usingWasm"]) {
        try {
          var result = Module["wasmMemory"].grow((size - oldSize) / wasmPageSize);
          if (result !== (-1 | 0)) {
            return Module["buffer"] = Module["wasmMemory"].buffer;
          } else {
            return null;
          }
        } catch (e) {
          return null;
        }
      } else {
        exports["__growWasmMemory"]((size - oldSize) / wasmPageSize);
        return Module["buffer"] !== old ? Module["buffer"] : null;
      }
    };
    Module["asm"] = function(global2, env2, providedBuffer2) {
      global2 = fixImports(global2);
      env2 = fixImports(env2);
      if (!env2["table"]) {
        var TABLE_SIZE = Module["wasmTableSize"];
        if (TABLE_SIZE === void 0)
          TABLE_SIZE = 1024;
        var MAX_TABLE_SIZE = Module["wasmMaxTableSize"];
        if (typeof WebAssembly === "object" && typeof WebAssembly.Table === "function") {
          if (MAX_TABLE_SIZE !== void 0) {
            env2["table"] = new WebAssembly.Table({
              initial: TABLE_SIZE,
              maximum: MAX_TABLE_SIZE,
              element: "anyfunc"
            });
          } else {
            env2["table"] = new WebAssembly.Table({
              initial: TABLE_SIZE,
              element: "anyfunc"
            });
          }
        } else {
          env2["table"] = new Array(TABLE_SIZE);
        }
        Module["wasmTable"] = env2["table"];
      }
      if (!env2["memoryBase"]) {
        env2["memoryBase"] = Module["STATIC_BASE"];
      }
      if (!env2["tableBase"]) {
        env2["tableBase"] = 0;
      }
      var exports2;
      var methods = method.split(",");
      for (var i2 = 0; i2 < methods.length; i2++) {
        var curr = methods[i2];
        Module["printErr"]("trying binaryen method: " + curr);
        if (curr === "native-wasm") {
          if (exports2 = doNativeWasm(global2, env2))
            break;
        } else if (curr === "asmjs") {
          if (exports2 = doJustAsm(global2, env2, providedBuffer2))
            break;
        } else if (curr === "interpret-asm2wasm" || curr === "interpret-s-expr" || curr === "interpret-binary") {
          if (exports2 = doWasmPolyfill(global2, env2, providedBuffer2, curr))
            break;
        } else {
          throw "bad method: " + curr;
        }
      }
      if (!exports2)
        throw "no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods";
      Module["printErr"]("binaryen method succeeded.");
      return exports2;
    };
    var methodHandler = Module["asm"];
  }
  integrateWasmJS(Module);
  STATIC_BASE = 1024;
  STATICTOP = STATIC_BASE + 42112;
  __ATINIT__.push();
  memoryInitializer = Module["wasmJSMethod"].indexOf("asmjs") >= 0 || Module["wasmJSMethod"].indexOf("interpret-asm2wasm") >= 0 ? "worker-wasm.js.mem" : null;
  var STATIC_BUMP = 42112;
  Module["STATIC_BASE"] = STATIC_BASE;
  Module["STATIC_BUMP"] = STATIC_BUMP;
  var tempDoublePtr = STATICTOP;
  STATICTOP += 16;
  function ___setErrNo(value) {
    if (Module["___errno_location"])
      HEAP32[Module["___errno_location"]() >> 2] = value;
    return value;
  }
  Module["_sbrk"] = _sbrk;
  function _abort() {
    Module["abort"]();
  }
  Module["_llvm_bswap_i32"] = _llvm_bswap_i32;
  Module["_llvm_bswap_i16"] = _llvm_bswap_i16;
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
    return dest;
  }
  Module["_memcpy"] = _memcpy;
  DYNAMICTOP_PTR = allocate(1, "i32", ALLOC_STATIC);
  STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);
  STACK_MAX = STACK_BASE + TOTAL_STACK;
  DYNAMIC_BASE = Runtime.alignMemory(STACK_MAX);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  Module["wasmTableSize"] = 6;
  Module["wasmMaxTableSize"] = 6;
  function invoke_iiii(index, a1, a2, a3) {
    try {
      return Module["dynCall_iiii"](index, a1, a2, a3);
    } catch (e) {
      if (typeof e !== "number" && e !== "longjmp")
        throw e;
      Module["setThrew"](1, 0);
    }
  }
  function invoke_vii(index, a1, a2) {
    try {
      Module["dynCall_vii"](index, a1, a2);
    } catch (e) {
      if (typeof e !== "number" && e !== "longjmp")
        throw e;
      Module["setThrew"](1, 0);
    }
  }
  function invoke_iii(index, a1, a2) {
    try {
      return Module["dynCall_iii"](index, a1, a2);
    } catch (e) {
      if (typeof e !== "number" && e !== "longjmp")
        throw e;
      Module["setThrew"](1, 0);
    }
  }
  Module.asmGlobalArg = {
    Math,
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    NaN: NaN,
    Infinity: Infinity
  };
  Module.asmLibraryArg = {
    abort,
    assert,
    enlargeMemory,
    getTotalMemory,
    abortOnCannotGrowMemory,
    invoke_iiii,
    invoke_vii,
    invoke_iii,
    _abort,
    _emscripten_memcpy_big,
    ___setErrNo,
    DYNAMICTOP_PTR,
    tempDoublePtr,
    ABORT,
    STACKTOP,
    STACK_MAX
  };
  var asm = Module["asm"](Module.asmGlobalArg, Module.asmLibraryArg, buffer);
  Module["asm"] = asm;
  Module["_nimiq_argon2_verify"] = function() {
    return Module["asm"]["_nimiq_argon2_verify"].apply(null, arguments);
  };
  Module["stackSave"] = function() {
    return Module["asm"]["stackSave"].apply(null, arguments);
  };
  Module["getTempRet0"] = function() {
    return Module["asm"]["getTempRet0"].apply(null, arguments);
  };
  Module["_nimiq_kdf_legacy"] = function() {
    return Module["asm"]["_nimiq_kdf_legacy"].apply(null, arguments);
  };
  Module["_ed25519_sign"] = function() {
    return Module["asm"]["_ed25519_sign"].apply(null, arguments);
  };
  Module["_nimiq_blake2"] = function() {
    return Module["asm"]["_nimiq_blake2"].apply(null, arguments);
  };
  Module["_nimiq_argon2_no_wipe"] = function() {
    return Module["asm"]["_nimiq_argon2_no_wipe"].apply(null, arguments);
  };
  Module["_ed25519_delinearized_partial_sign"] = function() {
    return Module["asm"]["_ed25519_delinearized_partial_sign"].apply(null, arguments);
  };
  Module["_nimiq_sha512"] = function() {
    return Module["asm"]["_nimiq_sha512"].apply(null, arguments);
  };
  var _sbrk = Module["_sbrk"] = function() {
    return Module["asm"]["_sbrk"].apply(null, arguments);
  };
  Module["_ed25519_derive_delinearized_private_key"] = function() {
    return Module["asm"]["_ed25519_derive_delinearized_private_key"].apply(null, arguments);
  };
  Module["stackAlloc"] = function() {
    return Module["asm"]["stackAlloc"].apply(null, arguments);
  };
  Module["_ed25519_create_commitment"] = function() {
    return Module["asm"]["_ed25519_create_commitment"].apply(null, arguments);
  };
  Module["_nimiq_argon2_target"] = function() {
    return Module["asm"]["_nimiq_argon2_target"].apply(null, arguments);
  };
  Module["_nimiq_argon2"] = function() {
    return Module["asm"]["_nimiq_argon2"].apply(null, arguments);
  };
  Module["_ed25519_delinearize_public_key"] = function() {
    return Module["asm"]["_ed25519_delinearize_public_key"].apply(null, arguments);
  };
  Module["_ed25519_add_scalars"] = function() {
    return Module["asm"]["_ed25519_add_scalars"].apply(null, arguments);
  };
  Module["_ed25519_public_key_derive"] = function() {
    return Module["asm"]["_ed25519_public_key_derive"].apply(null, arguments);
  };
  Module["setTempRet0"] = function() {
    return Module["asm"]["setTempRet0"].apply(null, arguments);
  };
  Module["_nimiq_kdf"] = function() {
    return Module["asm"]["_nimiq_kdf"].apply(null, arguments);
  };
  var _llvm_bswap_i16 = Module["_llvm_bswap_i16"] = function() {
    return Module["asm"]["_llvm_bswap_i16"].apply(null, arguments);
  };
  Module["_emscripten_get_global_libc"] = function() {
    return Module["asm"]["_emscripten_get_global_libc"].apply(null, arguments);
  };
  Module["_ed25519_verify"] = function() {
    return Module["asm"]["_ed25519_verify"].apply(null, arguments);
  };
  Module["_get_static_memory_size"] = function() {
    return Module["asm"]["_get_static_memory_size"].apply(null, arguments);
  };
  var _llvm_bswap_i32 = Module["_llvm_bswap_i32"] = function() {
    return Module["asm"]["_llvm_bswap_i32"].apply(null, arguments);
  };
  var _free = Module["_free"] = function() {
    return Module["asm"]["_free"].apply(null, arguments);
  };
  Module["runPostSets"] = function() {
    return Module["asm"]["runPostSets"].apply(null, arguments);
  };
  Module["setThrew"] = function() {
    return Module["asm"]["setThrew"].apply(null, arguments);
  };
  Module["establishStackSpace"] = function() {
    return Module["asm"]["establishStackSpace"].apply(null, arguments);
  };
  Module["_get_static_memory_start"] = function() {
    return Module["asm"]["_get_static_memory_start"].apply(null, arguments);
  };
  Module["_nimiq_sha256"] = function() {
    return Module["asm"]["_nimiq_sha256"].apply(null, arguments);
  };
  Module["stackRestore"] = function() {
    return Module["asm"]["stackRestore"].apply(null, arguments);
  };
  Module["_ed25519_hash_public_keys"] = function() {
    return Module["asm"]["_ed25519_hash_public_keys"].apply(null, arguments);
  };
  var _malloc = Module["_malloc"] = function() {
    return Module["asm"]["_malloc"].apply(null, arguments);
  };
  var _memcpy = Module["_memcpy"] = function() {
    return Module["asm"]["_memcpy"].apply(null, arguments);
  };
  Module["_ed25519_aggregate_commitments"] = function() {
    return Module["asm"]["_ed25519_aggregate_commitments"].apply(null, arguments);
  };
  Module["_ed25519_aggregate_delinearized_public_keys"] = function() {
    return Module["asm"]["_ed25519_aggregate_delinearized_public_keys"].apply(null, arguments);
  };
  Module["dynCall_iiii"] = function() {
    return Module["asm"]["dynCall_iiii"].apply(null, arguments);
  };
  Module["dynCall_vii"] = function() {
    return Module["asm"]["dynCall_vii"].apply(null, arguments);
  };
  Module["dynCall_iii"] = function() {
    return Module["asm"]["dynCall_iii"].apply(null, arguments);
  };
  Runtime.stackAlloc = Module["stackAlloc"];
  Runtime.stackSave = Module["stackSave"];
  Runtime.stackRestore = Module["stackRestore"];
  Runtime.establishStackSpace = Module["establishStackSpace"];
  Runtime.setTempRet0 = Module["setTempRet0"];
  Runtime.getTempRet0 = Module["getTempRet0"];
  Module["asm"] = asm;
  if (memoryInitializer) {
    if (typeof Module["locateFile"] === "function") {
      memoryInitializer = Module["locateFile"](memoryInitializer);
    } else if (Module["memoryInitializerPrefixURL"]) {
      memoryInitializer = Module["memoryInitializerPrefixURL"] + memoryInitializer;
    }
    if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
      var data = Module["readBinary"](memoryInitializer);
      HEAPU8.set(data, Runtime.GLOBAL_BASE);
    } else {
      let doBrowserLoad = function() {
        Module["readAsync"](memoryInitializer, applyMemoryInitializer, function() {
          throw "could not load memory initializer " + memoryInitializer;
        });
      };
      addRunDependency();
      var applyMemoryInitializer = function(data2) {
        if (data2.byteLength)
          data2 = new Uint8Array(data2);
        HEAPU8.set(data2, Runtime.GLOBAL_BASE);
        if (Module["memoryInitializerRequest"])
          delete Module["memoryInitializerRequest"].response;
        removeRunDependency();
      };
      if (Module["memoryInitializerRequest"]) {
        let useRequest = function() {
          var request = Module["memoryInitializerRequest"];
          if (request.status !== 200 && request.status !== 0) {
            console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
            doBrowserLoad();
            return;
          }
          applyMemoryInitializer(request.response);
        };
        if (Module["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }
  ExitStatus.prototype = new Error();
  ExitStatus.prototype.constructor = ExitStatus;
  var initialStackTop;
  dependenciesFulfilled = function runCaller() {
    if (!Module["calledRun"])
      run();
    if (!Module["calledRun"])
      dependenciesFulfilled = runCaller;
  };
  Module["callMain"] = Module.callMain = function callMain(args) {
    args = args || [];
    ensureInitRuntime();
    var argc = args.length + 1;
    function pad() {
      for (var i3 = 0; i3 < 4 - 1; i3++) {
        argv.push(0);
      }
    }
    var argv = [allocate(intArrayFromString(Module["thisProgram"]), "i8", ALLOC_NORMAL)];
    pad();
    for (var i2 = 0; i2 < argc - 1; i2 = i2 + 1) {
      argv.push(allocate(intArrayFromString(args[i2]), "i8", ALLOC_NORMAL));
      pad();
    }
    argv.push(0);
    argv = allocate(argv, "i32", ALLOC_NORMAL);
    try {
      var ret = Module["_main"](argc, argv, 0);
      exit(ret, true);
    } catch (e) {
      if (e instanceof ExitStatus) {
        return;
      } else if (e == "SimulateInfiniteLoop") {
        Module["noExitRuntime"] = true;
        return;
      } else {
        var toLog = e;
        if (e && typeof e === "object" && e.stack) {
          toLog = [e, e.stack];
        }
        Module.printErr("exception thrown: " + toLog);
        Module["quit"](1, e);
      }
    } finally {
    }
  };
  function run(args) {
    args = args || Module["arguments"];
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0)
      return;
    if (Module["calledRun"])
      return;
    function doRun() {
      if (Module["calledRun"])
        return;
      Module["calledRun"] = true;
      if (ABORT)
        return;
      ensureInitRuntime();
      preMain();
      if (Module["onRuntimeInitialized"])
        Module["onRuntimeInitialized"]();
      if (Module["_main"] && shouldRunNow)
        Module["callMain"](args);
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = Module.run = run;
  function exit(status, implicit) {
    if (implicit && Module["noExitRuntime"]) {
      return;
    }
    if (Module["noExitRuntime"]) ; else {
      ABORT = true;
      STACKTOP = initialStackTop;
      exitRuntime();
      if (Module["onExit"])
        Module["onExit"](status);
    }
    if (ENVIRONMENT_IS_NODE) {
      process["exit"](status);
    }
    Module["quit"](status, new ExitStatus(status));
  }
  Module["exit"] = Module.exit = exit;
  var abortDecorators = [];
  function abort(what) {
    if (what !== void 0) {
      Module.print(what);
      Module.printErr(what);
      what = JSON.stringify(what);
    } else {
      what = "";
    }
    ABORT = true;
    var extra = "\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";
    var output = "abort(" + what + ") at " + stackTrace() + extra;
    if (abortDecorators) {
      abortDecorators.forEach(function(decorator) {
        output = decorator(output, what);
      });
    }
    throw output;
  }
  Module["abort"] = Module.abort = abort;
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  var shouldRunNow = true;
  if (Module["noInitialRun"]) {
    shouldRunNow = false;
  }
  Module["noExitRuntime"] = true;
  run();
  return Module;
}

var workerWasm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  init: init
});

exports.Account = Account;
exports.Address = Address;
exports.BasicAccount = BasicAccount;
exports.BasicTransaction = BasicTransaction;
exports.BufferUtils = BufferUtils;
exports.Commitment = Commitment;
exports.CommitmentPair = CommitmentPair;
exports.CryptoUtils = CryptoUtils;
exports.Entropy = Entropy;
exports.ExtendedPrivateKey = ExtendedPrivateKey;
exports.ExtendedTransaction = ExtendedTransaction;
exports.GenesisConfig = GenesisConfig;
exports.Hash = Hash;
exports.HashedTimeLockedContract = HashedTimeLockedContract;
exports.KeyPair = KeyPair;
exports.MerklePath = MerklePath;
exports.MerkleTree = MerkleTree;
exports.MnemonicUtils = MnemonicUtils;
exports.MultiSigWallet = MultiSigWallet;
exports.PartialSignature = PartialSignature;
exports.Policy = Policy;
exports.PrivateKey = PrivateKey;
exports.PublicKey = PublicKey;
exports.RandomSecret = RandomSecret;
exports.Secret = Secret;
exports.SerialBuffer = SerialBuffer;
exports.Signature = Signature;
exports.SignatureProof = SignatureProof;
exports.Transaction = Transaction;
exports.VestingContract = VestingContract;
exports.Wallet = Wallet;
exports.initialize = initialize;
//# sourceMappingURL=index.js.map
